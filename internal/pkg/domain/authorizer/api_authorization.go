/*
AAA - External Authorizer

This swagger documentation provides all Authorization api details. External Authorizer service provides authentication and authorization capabilities for users and machines.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package authorizerdomain

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// AuthorizationApiService AuthorizationApi service
type AuthorizationApiService service

type ApiAuthorizeTokenRequest struct {
	ctx context.Context
	ApiService *AuthorizationApiService
	xCOREOSTID *string
	xCoreosAccess *string
	xCoreosRequestId *string
	xCoreosAuth *string
	xCoreosOriginToken *string
	authorizationRequest *AuthorizationRequest
}

// Tenant id
func (r ApiAuthorizeTokenRequest) XCOREOSTID(xCOREOSTID string) ApiAuthorizeTokenRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// core-os access token
func (r ApiAuthorizeTokenRequest) XCoreosAccess(xCoreosAccess string) ApiAuthorizeTokenRequest {
	r.xCoreosAccess = &xCoreosAccess
	return r
}

// Unique request id
func (r ApiAuthorizeTokenRequest) XCoreosRequestId(xCoreosRequestId string) ApiAuthorizeTokenRequest {
	r.xCoreosRequestId = &xCoreosRequestId
	return r
}

// core-os authentication token
func (r ApiAuthorizeTokenRequest) XCoreosAuth(xCoreosAuth string) ApiAuthorizeTokenRequest {
	r.xCoreosAuth = &xCoreosAuth
	return r
}

// Token sent from originating app requesting access.
func (r ApiAuthorizeTokenRequest) XCoreosOriginToken(xCoreosOriginToken string) ApiAuthorizeTokenRequest {
	r.xCoreosOriginToken = &xCoreosOriginToken
	return r
}

// 
func (r ApiAuthorizeTokenRequest) AuthorizationRequest(authorizationRequest AuthorizationRequest) ApiAuthorizeTokenRequest {
	r.authorizationRequest = &authorizationRequest
	return r
}

func (r ApiAuthorizeTokenRequest) Execute() (*SuccessAuthResponse, *http.Response, error) {
	return r.ApiService.AuthorizeTokenExecute(r)
}

/*
AuthorizeToken Authorizes the input request.

This endpoint validates the input token. Tokens should be parsed and validated in regular web, native, and single-page applications to make sure the token isnâ€™t compromised and the signature is authentic. Tokens should be verified to decrease security risks if the token has been, for example, tampered with, misused, or has expired. JWT validation checks the structure, claims, and signature to assure the least amount of risk.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizeTokenRequest
*/
func (a *AuthorizationApiService) AuthorizeToken(ctx context.Context) ApiAuthorizeTokenRequest {
	return ApiAuthorizeTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuccessAuthResponse
func (a *AuthorizationApiService) AuthorizeTokenExecute(r ApiAuthorizeTokenRequest) (*SuccessAuthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessAuthResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationApiService.AuthorizeToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/token/authorize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCoreosAccess == nil {
		return localVarReturnValue, nil, reportError("xCoreosAccess is required and must be specified")
	}
	if r.xCoreosRequestId == nil {
		return localVarReturnValue, nil, reportError("xCoreosRequestId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-Coreos-Access"] = parameterToString(*r.xCoreosAccess, "")
	localVarHeaderParams["X-Coreos-Request-Id"] = parameterToString(*r.xCoreosRequestId, "")
	if r.xCoreosAuth != nil {
		localVarHeaderParams["X-Coreos-Auth"] = parameterToString(*r.xCoreosAuth, "")
	}
	if r.xCoreosOriginToken != nil {
		localVarHeaderParams["X-Coreos-Origin-Token"] = parameterToString(*r.xCoreosOriginToken, "")
	}
	// body params
	localVarPostBody = r.authorizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateTokenRequest struct {
	ctx context.Context
	ApiService *AuthorizationApiService
	xCOREOSTID *string
	xCoreosAccess *string
	xCoreosRequestId *string
	xCoreosAuth *string
	xCoreosOriginToken *string
}

// Tenant id
func (r ApiValidateTokenRequest) XCOREOSTID(xCOREOSTID string) ApiValidateTokenRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// core-os access token
func (r ApiValidateTokenRequest) XCoreosAccess(xCoreosAccess string) ApiValidateTokenRequest {
	r.xCoreosAccess = &xCoreosAccess
	return r
}

// Unique request id
func (r ApiValidateTokenRequest) XCoreosRequestId(xCoreosRequestId string) ApiValidateTokenRequest {
	r.xCoreosRequestId = &xCoreosRequestId
	return r
}

// core-os authentication token
func (r ApiValidateTokenRequest) XCoreosAuth(xCoreosAuth string) ApiValidateTokenRequest {
	r.xCoreosAuth = &xCoreosAuth
	return r
}

// Token sent from originating app requesting access.
func (r ApiValidateTokenRequest) XCoreosOriginToken(xCoreosOriginToken string) ApiValidateTokenRequest {
	r.xCoreosOriginToken = &xCoreosOriginToken
	return r
}

func (r ApiValidateTokenRequest) Execute() (*SuccessAuthResponse, *http.Response, error) {
	return r.ApiService.ValidateTokenExecute(r)
}

/*
ValidateToken Validate the input token.

This endpoint authorizes the input request. If the token is valid and it has valid permissions to access the specified method then it returns the success response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateTokenRequest
*/
func (a *AuthorizationApiService) ValidateToken(ctx context.Context) ApiValidateTokenRequest {
	return ApiValidateTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuccessAuthResponse
func (a *AuthorizationApiService) ValidateTokenExecute(r ApiValidateTokenRequest) (*SuccessAuthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessAuthResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationApiService.ValidateToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/token/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCoreosAccess == nil {
		return localVarReturnValue, nil, reportError("xCoreosAccess is required and must be specified")
	}
	if r.xCoreosRequestId == nil {
		return localVarReturnValue, nil, reportError("xCoreosRequestId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-Coreos-Access"] = parameterToString(*r.xCoreosAccess, "")
	if r.xCoreosAuth != nil {
		localVarHeaderParams["X-Coreos-Auth"] = parameterToString(*r.xCoreosAuth, "")
	}
	if r.xCoreosOriginToken != nil {
		localVarHeaderParams["X-Coreos-Origin-Token"] = parameterToString(*r.xCoreosOriginToken, "")
	}
	localVarHeaderParams["X-Coreos-Request-Id"] = parameterToString(*r.xCoreosRequestId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
