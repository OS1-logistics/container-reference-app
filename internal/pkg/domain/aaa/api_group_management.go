/*
Authentication And Authorization (AAA) Service

This swagger documentation provides all AAA API details. AAA service provides authentication and authorization capabilities for users.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package aaadomain

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// GroupManagementApiService GroupManagementApi service
type GroupManagementApiService service

type ApiCreateGroupRequest struct {
	ctx context.Context
	ApiService *GroupManagementApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	groupCreateRequest *GroupCreateRequest
	xCOREOSAUTH *string
	xCOREOSUSERINFO *string
}

// Unique request ID
func (r ApiCreateGroupRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiCreateGroupRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant ID
func (r ApiCreateGroupRequest) XCOREOSTID(xCOREOSTID string) ApiCreateGroupRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiCreateGroupRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiCreateGroupRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// 
func (r ApiCreateGroupRequest) GroupCreateRequest(groupCreateRequest GroupCreateRequest) ApiCreateGroupRequest {
	r.groupCreateRequest = &groupCreateRequest
	return r
}

// Core-os authentication token.
func (r ApiCreateGroupRequest) XCOREOSAUTH(xCOREOSAUTH string) ApiCreateGroupRequest {
	r.xCOREOSAUTH = &xCOREOSAUTH
	return r
}

// User info
func (r ApiCreateGroupRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiCreateGroupRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiCreateGroupRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.CreateGroupExecute(r)
}

/*
CreateGroup Create Group

This endpoint creates a Group of Users and Roles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGroupRequest
*/
func (a *GroupManagementApiService) CreateGroup(ctx context.Context) ApiCreateGroupRequest {
	return ApiCreateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *GroupManagementApiService) CreateGroupExecute(r ApiCreateGroupRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupManagementApiService.CreateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/aaa/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.groupCreateRequest == nil {
		return localVarReturnValue, nil, reportError("groupCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSAUTH != nil {
		localVarHeaderParams["X-COREOS-AUTH"] = parameterToString(*r.xCOREOSAUTH, "")
	}
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.groupCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllGroupsRequest struct {
	ctx context.Context
	ApiService *GroupManagementApiService
	groupId string
	xCOREOSREQUESTID *string
	xCOREOSACCESS *string
	xCOREOSTID *string
	xCOREOSAUTH *string
	xCOREOSUSERINFO *string
}

// Unique request ID
func (r ApiGetAllGroupsRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetAllGroupsRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Core-os access token
func (r ApiGetAllGroupsRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetAllGroupsRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Tenant ID
func (r ApiGetAllGroupsRequest) XCOREOSTID(xCOREOSTID string) ApiGetAllGroupsRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os authentication token.
func (r ApiGetAllGroupsRequest) XCOREOSAUTH(xCOREOSAUTH string) ApiGetAllGroupsRequest {
	r.xCOREOSAUTH = &xCOREOSAUTH
	return r
}

// User info
func (r ApiGetAllGroupsRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetAllGroupsRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetAllGroupsRequest) Execute() (*SuccessGroupResponse, *http.Response, error) {
	return r.ApiService.GetAllGroupsExecute(r)
}

/*
GetAllGroups Get Groups

This endpoint retrieves details of a Group of a Tenant by groupId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiGetAllGroupsRequest
*/
func (a *GroupManagementApiService) GetAllGroups(ctx context.Context, groupId string) ApiGetAllGroupsRequest {
	return ApiGetAllGroupsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return SuccessGroupResponse
func (a *GroupManagementApiService) GetAllGroupsExecute(r ApiGetAllGroupsRequest) (*SuccessGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupManagementApiService.GetAllGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/aaa/groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSAUTH != nil {
		localVarHeaderParams["X-COREOS-AUTH"] = parameterToString(*r.xCOREOSAUTH, "")
	}
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupRequest struct {
	ctx context.Context
	ApiService *GroupManagementApiService
	xCOREOSREQUESTID *string
	xCOREOSACCESS *string
	xCOREOSTID *string
	xCOREOSAUTH *string
	xCOREOSUSERINFO *string
}

// Unique request ID
func (r ApiGetGroupRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetGroupRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Core-os access token
func (r ApiGetGroupRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetGroupRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Tenant ID
func (r ApiGetGroupRequest) XCOREOSTID(xCOREOSTID string) ApiGetGroupRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os authentication token.
func (r ApiGetGroupRequest) XCOREOSAUTH(xCOREOSAUTH string) ApiGetGroupRequest {
	r.xCOREOSAUTH = &xCOREOSAUTH
	return r
}

// User info
func (r ApiGetGroupRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetGroupRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetGroupRequest) Execute() (*SuccessGroupsResponse, *http.Response, error) {
	return r.ApiService.GetGroupExecute(r)
}

/*
GetGroup Get all Group

This API retrieves the details of all Groups of Users and Roles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGroupRequest
*/
func (a *GroupManagementApiService) GetGroup(ctx context.Context) ApiGetGroupRequest {
	return ApiGetGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuccessGroupsResponse
func (a *GroupManagementApiService) GetGroupExecute(r ApiGetGroupRequest) (*SuccessGroupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupManagementApiService.GetGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/aaa/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSAUTH != nil {
		localVarHeaderParams["X-COREOS-AUTH"] = parameterToString(*r.xCOREOSAUTH, "")
	}
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGroupRequest struct {
	ctx context.Context
	ApiService *GroupManagementApiService
	groupId string
	xCOREOSREQUESTID *string
	xCOREOSACCESS *string
	xCOREOSTID *string
	groupUpdateRequest *GroupUpdateRequest
	xCOREOSAUTH *string
	xCOREOSUSERINFO *string
}

// Unique request ID
func (r ApiUpdateGroupRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiUpdateGroupRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Core-os access token
func (r ApiUpdateGroupRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiUpdateGroupRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Tenant ID
func (r ApiUpdateGroupRequest) XCOREOSTID(xCOREOSTID string) ApiUpdateGroupRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// 
func (r ApiUpdateGroupRequest) GroupUpdateRequest(groupUpdateRequest GroupUpdateRequest) ApiUpdateGroupRequest {
	r.groupUpdateRequest = &groupUpdateRequest
	return r
}

// Core-os authentication token.
func (r ApiUpdateGroupRequest) XCOREOSAUTH(xCOREOSAUTH string) ApiUpdateGroupRequest {
	r.xCOREOSAUTH = &xCOREOSAUTH
	return r
}

// User info
func (r ApiUpdateGroupRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiUpdateGroupRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiUpdateGroupRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UpdateGroupExecute(r)
}

/*
UpdateGroup Update Group

This endpoint updates a Group of Users and Roles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiUpdateGroupRequest
*/
func (a *GroupManagementApiService) UpdateGroup(ctx context.Context, groupId string) ApiUpdateGroupRequest {
	return ApiUpdateGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *GroupManagementApiService) UpdateGroupExecute(r ApiUpdateGroupRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupManagementApiService.UpdateGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/aaa/groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.groupUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("groupUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSAUTH != nil {
		localVarHeaderParams["X-COREOS-AUTH"] = parameterToString(*r.xCOREOSAUTH, "")
	}
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.groupUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGroupRolesMappingRequest struct {
	ctx context.Context
	ApiService *GroupManagementApiService
	groupId string
	xCOREOSREQUESTID *string
	xCOREOSACCESS *string
	xCOREOSTID *string
	groupRolesMappingUpdateRequest *GroupRolesMappingUpdateRequest
	xCOREOSAUTH *string
	xCOREOSUSERINFO *string
}

// Unique request ID
func (r ApiUpdateGroupRolesMappingRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiUpdateGroupRolesMappingRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Core-os access token
func (r ApiUpdateGroupRolesMappingRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiUpdateGroupRolesMappingRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Tenant ID
func (r ApiUpdateGroupRolesMappingRequest) XCOREOSTID(xCOREOSTID string) ApiUpdateGroupRolesMappingRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// 
func (r ApiUpdateGroupRolesMappingRequest) GroupRolesMappingUpdateRequest(groupRolesMappingUpdateRequest GroupRolesMappingUpdateRequest) ApiUpdateGroupRolesMappingRequest {
	r.groupRolesMappingUpdateRequest = &groupRolesMappingUpdateRequest
	return r
}

// Core-os authentication token.
func (r ApiUpdateGroupRolesMappingRequest) XCOREOSAUTH(xCOREOSAUTH string) ApiUpdateGroupRolesMappingRequest {
	r.xCOREOSAUTH = &xCOREOSAUTH
	return r
}

// User info
func (r ApiUpdateGroupRolesMappingRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiUpdateGroupRolesMappingRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiUpdateGroupRolesMappingRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UpdateGroupRolesMappingExecute(r)
}

/*
UpdateGroupRolesMapping Update Roles mapping for a Group

This endpoint updates the Roles mapping for a Group membership. Default value: true. membership=true => Add specified Roles to the Group; membership=false => remove specified Roles from Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiUpdateGroupRolesMappingRequest
*/
func (a *GroupManagementApiService) UpdateGroupRolesMapping(ctx context.Context, groupId string) ApiUpdateGroupRolesMappingRequest {
	return ApiUpdateGroupRolesMappingRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *GroupManagementApiService) UpdateGroupRolesMappingExecute(r ApiUpdateGroupRolesMappingRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupManagementApiService.UpdateGroupRolesMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/aaa/groups/{groupId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.groupRolesMappingUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("groupRolesMappingUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSAUTH != nil {
		localVarHeaderParams["X-COREOS-AUTH"] = parameterToString(*r.xCOREOSAUTH, "")
	}
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.groupRolesMappingUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGroupUsersMappingRequest struct {
	ctx context.Context
	ApiService *GroupManagementApiService
	groupId string
	xCOREOSREQUESTID *string
	xCOREOSACCESS *string
	xCOREOSTID *string
	groupUsersMappingUpdateRequest *GroupUsersMappingUpdateRequest
	xCOREOSAUTH *string
	xCOREOSUSERINFO *string
}

// Unique request ID
func (r ApiUpdateGroupUsersMappingRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiUpdateGroupUsersMappingRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Core-os access token
func (r ApiUpdateGroupUsersMappingRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiUpdateGroupUsersMappingRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Tenant ID
func (r ApiUpdateGroupUsersMappingRequest) XCOREOSTID(xCOREOSTID string) ApiUpdateGroupUsersMappingRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// 
func (r ApiUpdateGroupUsersMappingRequest) GroupUsersMappingUpdateRequest(groupUsersMappingUpdateRequest GroupUsersMappingUpdateRequest) ApiUpdateGroupUsersMappingRequest {
	r.groupUsersMappingUpdateRequest = &groupUsersMappingUpdateRequest
	return r
}

// Core-os authentication token.
func (r ApiUpdateGroupUsersMappingRequest) XCOREOSAUTH(xCOREOSAUTH string) ApiUpdateGroupUsersMappingRequest {
	r.xCOREOSAUTH = &xCOREOSAUTH
	return r
}

// User info
func (r ApiUpdateGroupUsersMappingRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiUpdateGroupUsersMappingRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiUpdateGroupUsersMappingRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UpdateGroupUsersMappingExecute(r)
}

/*
UpdateGroupUsersMapping Update roles mapping for a Group

This endpoint updates the User mapping for a Group membership. Default value: true. membership=true => Add specified Users to the Group; membership=false => remove specified Users from Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiUpdateGroupUsersMappingRequest
*/
func (a *GroupManagementApiService) UpdateGroupUsersMapping(ctx context.Context, groupId string) ApiUpdateGroupUsersMappingRequest {
	return ApiUpdateGroupUsersMappingRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *GroupManagementApiService) UpdateGroupUsersMappingExecute(r ApiUpdateGroupUsersMappingRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupManagementApiService.UpdateGroupUsersMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/aaa/groups/{groupId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.groupUsersMappingUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("groupUsersMappingUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSAUTH != nil {
		localVarHeaderParams["X-COREOS-AUTH"] = parameterToString(*r.xCOREOSAUTH, "")
	}
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.groupUsersMappingUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
