/*
Container Service

**API documentation for Container Service**

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package containerdomain

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ContainerBatchProcessingApiService ContainerBatchProcessingApi service
type ContainerBatchProcessingApiService service

type ApiContainerTypeBatchPostRequest struct {
	ctx context.Context
	ApiService *ContainerBatchProcessingApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerType string
	xCOREOSORIGINTOKEN *string
	containerCreationBatchRequest *ContainerCreationBatchRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiContainerTypeBatchPostRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiContainerTypeBatchPostRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiContainerTypeBatchPostRequest) XCOREOSTID(xCOREOSTID string) ApiContainerTypeBatchPostRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiContainerTypeBatchPostRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiContainerTypeBatchPostRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// App requesting for the attributes.
func (r ApiContainerTypeBatchPostRequest) XCOREOSORIGINTOKEN(xCOREOSORIGINTOKEN string) ApiContainerTypeBatchPostRequest {
	r.xCOREOSORIGINTOKEN = &xCOREOSORIGINTOKEN
	return r
}

// Create new containers by batch request
func (r ApiContainerTypeBatchPostRequest) ContainerCreationBatchRequest(containerCreationBatchRequest ContainerCreationBatchRequest) ApiContainerTypeBatchPostRequest {
	r.containerCreationBatchRequest = &containerCreationBatchRequest
	return r
}

// Core-os user info
func (r ApiContainerTypeBatchPostRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiContainerTypeBatchPostRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiContainerTypeBatchPostRequest) Execute() (*BatchSuccessResponse, *http.Response, error) {
	return r.ApiService.ContainerTypeBatchPostExecute(r)
}

/*
ContainerTypeBatchPost Create container in batches

**API to create Container in batch via JSON payload for a container type.**
| PARAMETER | DESCRIPTION | TYPE | VALIDATION |
| - | - | - | - |
| `payload` | Array of container creation request. | | **maxItems**: 1024 **minItems**: 1 |
 | ㅤ↳`refID`* | Reference ID received for each container create request. | string |
 | `trackingDetails` | Field to represent tracking ID (such as AWB) for a container which is usually pasted on the container and used for scanning it.<br>There can be multiple tracking IDs for a container, owned by different operators and hence it will be stored as a list. |
 | ㅤㅤ↳`operator`* | Field to specify the owner of the tracking ID. | string | **minLength**: 3 **maxLength**: 64<br>**example**: Delhivery |
 | ㅤㅤ↳`trackingId`* | Tracking ID. | string | **minLength**: 1 **maxLength**: 128<br>**example**: 132121232423232 |
 | ㅤㅤ↳`isPrimary`* | It defines whether it is a primary tracking ID or not. If none of the tracking details is set as primary we assume first tracking ID as a primary tracking ID. | boolean | **default**: false |
 | ㅤ↳`attributes` | A map to provide values for the attributes defined in Container-type configuration APIs. |
 | ㅤ↳`items` | List of items can be added into a container only if the container-type is a leaf. |
 | ㅤㅤ↳`name`* | Name of the item. | string | **minLength**: 3 **maxLength**: 128<br>**example**: pant/shirt |
 | ㅤㅤ↳`code` | Code of the item. | string | **minLength**: 3 **maxLength**: 128 |
 | ㅤㅤ↳`cost`* | cost of the item. |
 | ㅤㅤㅤ↳`unit` | Represents unit price of the item.. |
 | ㅤㅤㅤㅤ↳`amount` | The value of the amount accurate to three decimal places. | number |
 | ㅤㅤㅤㅤ↳`currency` | Currency of the price of the item. | string |
 | ㅤㅤㅤ↳`total`* | Represents total price of the item. |
 | ㅤㅤㅤㅤ↳`amount` | The value of the amount accurate to three decimal places. | number |
 | ㅤㅤㅤㅤ↳`currency` | Currency of the price of the item. | string |
 | ㅤㅤ↳`quantity` |
 | ㅤㅤㅤ↳`value` | A number quantifying measurement. | integer |
 | ㅤㅤㅤ↳`unit` | Unit for measurement. | string | **​​Enum**: [ cm, m, l, ml, nos, g, kg, mm ] |
 | ㅤ↳`isHazmat` | Represents whether this container can contain hazardous materials or not. | boolean | **default**: false |
   | ㅤ↳`isContainerizable` | Defines whether containers can be put into other containers or not. | boolean | **default**: true |
   | `callback` | Represents callback URL, which can be to notify status(success/failed) of API.| object | {url: "string", meta: {}} |
   *This is required.

   **HTTP Status Code Summary**

  | Code | Description |
      | --- | ---- |
   | **202 - Accepted** | Everything worked as expected. |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
    | **401 - Unauthorized** | No valid API key provided. |
    | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerType Type of container
 @return ApiContainerTypeBatchPostRequest
*/
func (a *ContainerBatchProcessingApiService) ContainerTypeBatchPost(ctx context.Context, containerType string) ApiContainerTypeBatchPostRequest {
	return ApiContainerTypeBatchPostRequest{
		ApiService: a,
		ctx: ctx,
		containerType: containerType,
	}
}

// Execute executes the request
//  @return BatchSuccessResponse
func (a *ContainerBatchProcessingApiService) ContainerTypeBatchPostExecute(r ApiContainerTypeBatchPostRequest) (*BatchSuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchSuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerBatchProcessingApiService.ContainerTypeBatchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerType}/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"containerType"+"}", url.PathEscape(parameterToString(r.containerType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSORIGINTOKEN == nil {
		return localVarReturnValue, nil, reportError("xCOREOSORIGINTOKEN is required and must be specified")
	}
	if r.containerCreationBatchRequest == nil {
		return localVarReturnValue, nil, reportError("containerCreationBatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	localVarHeaderParams["X-COREOS-ORIGIN-TOKEN"] = parameterToString(*r.xCOREOSORIGINTOKEN, "")
	// body params
	localVarPostBody = r.containerCreationBatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContainerTypeBatchPutRequest struct {
	ctx context.Context
	ApiService *ContainerBatchProcessingApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerType string
	xCOREOSORIGINTOKEN *string
	containerUpdateBatchRequest *ContainerUpdateBatchRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiContainerTypeBatchPutRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiContainerTypeBatchPutRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiContainerTypeBatchPutRequest) XCOREOSTID(xCOREOSTID string) ApiContainerTypeBatchPutRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiContainerTypeBatchPutRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiContainerTypeBatchPutRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// App requesting for the attributes.
func (r ApiContainerTypeBatchPutRequest) XCOREOSORIGINTOKEN(xCOREOSORIGINTOKEN string) ApiContainerTypeBatchPutRequest {
	r.xCOREOSORIGINTOKEN = &xCOREOSORIGINTOKEN
	return r
}

// update batch request for container type
func (r ApiContainerTypeBatchPutRequest) ContainerUpdateBatchRequest(containerUpdateBatchRequest ContainerUpdateBatchRequest) ApiContainerTypeBatchPutRequest {
	r.containerUpdateBatchRequest = &containerUpdateBatchRequest
	return r
}

// Core-os user info
func (r ApiContainerTypeBatchPutRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiContainerTypeBatchPutRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiContainerTypeBatchPutRequest) Execute() (*BatchSuccessResponse, *http.Response, error) {
	return r.ApiService.ContainerTypeBatchPutExecute(r)
}

/*
ContainerTypeBatchPut Perform update operation on container in batches

**API to update Container in batch via JSON payload.**

| PARAMETER | DESCRIPTION | TYPE | VALIDATION |
| - | - | - | - |
| `payload` | Array of container update request. |
 | ㅤ↳`containerId` | unique identifier of each container. | string |
 | ㅤ↳`data` | Attributes that define a container and can be modified after container creation. |
 | `trackingDetails` | Field to represent tracking ID (such as AWB) for a container which is usually pasted on the container and used for scanning it.<br>There can be multiple tracking IDs for a container, owned by different operators and hence it will be stored as a list. |
   | ㅤㅤ↳`operator`* | Field to specify the owner of the tracking ID. | string | **minLength**: 3 **maxLength**: 64<br>**example**: Delhivery |
   | ㅤㅤ↳`trackingId`* | Tracking ID. | string | **minLength**: 1 **maxLength**: 128<br>**example**: 132121232423232 |
   | ㅤㅤ↳`isPrimary`* | It defines whether it is a primary tracking ID or not. If none of the tracking details is set as primary we assume first tracking ID as a primary tracking id. | boolean | **default**: false |
   | ㅤ↳`attributes` | A map to provide values for the attributes defined in Container-type configuration APIs. |
   | ㅤ↳`items` | List of items can be added into container only if container-type is a leaf. |
     | ㅤㅤ↳`name`* | Name of the item. | string | **minLength**: 3 **maxLength**: 128<br>**example**: pant/shirt |
     | ㅤㅤ↳`code` | Code of the item. | string | **minLength**: 3 **maxLength**: 128 |
   | ㅤㅤ↳`cost`* | cost of the item. |
   | ㅤㅤㅤ↳`unit` | Represents unit price of the item.. |
   | ㅤㅤㅤㅤ↳`amount` | The value of the amount accurate to three decimal places. | number |
   | ㅤㅤㅤㅤ↳`currency` | Currency of the price of the item. | string |
   | ㅤㅤㅤ↳`total`* | Represents total price of the item. |
   | ㅤㅤㅤㅤ↳`amount` | The value of the amount accurate to three decimal places. | number |
   | ㅤㅤㅤㅤ↳`currency` | Currency of the price of the item. | string |
   | ㅤㅤ↳`quantity` |
   | ㅤㅤㅤ↳`value` | A number quantifying measurement. | integer |
   | ㅤㅤㅤ↳`unit` | Unit for measurement. | string | ​​**Enum**: [ cm, m, l, ml, nos, g, kg, mm ] |
   | ㅤㅤ↳`callback` | Represents callback URL, which can be to notify status(success/failed) of API. | string | A valid URL |
   | `callback` | Represents callback URL, which can be to notify status(success/failed) of API.| object | {url: "string", meta: {}} |
   *This is required.

   **HTTP Status Code Summary**
  | Code | Description |
  | --- | ---- |
    | **202 - Accepted** | Everything worked as expected. |
    | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
    | **401 - Unauthorized** | No valid API key provided. |
     | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerType Type of container
 @return ApiContainerTypeBatchPutRequest
*/
func (a *ContainerBatchProcessingApiService) ContainerTypeBatchPut(ctx context.Context, containerType string) ApiContainerTypeBatchPutRequest {
	return ApiContainerTypeBatchPutRequest{
		ApiService: a,
		ctx: ctx,
		containerType: containerType,
	}
}

// Execute executes the request
//  @return BatchSuccessResponse
func (a *ContainerBatchProcessingApiService) ContainerTypeBatchPutExecute(r ApiContainerTypeBatchPutRequest) (*BatchSuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchSuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerBatchProcessingApiService.ContainerTypeBatchPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerType}/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"containerType"+"}", url.PathEscape(parameterToString(r.containerType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSORIGINTOKEN == nil {
		return localVarReturnValue, nil, reportError("xCOREOSORIGINTOKEN is required and must be specified")
	}
	if r.containerUpdateBatchRequest == nil {
		return localVarReturnValue, nil, reportError("containerUpdateBatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	localVarHeaderParams["X-COREOS-ORIGIN-TOKEN"] = parameterToString(*r.xCOREOSORIGINTOKEN, "")
	// body params
	localVarPostBody = r.containerUpdateBatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatusOfBatchRequestRequest struct {
	ctx context.Context
	ApiService *ContainerBatchProcessingApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerType string
	batchId *string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetStatusOfBatchRequestRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetStatusOfBatchRequestRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetStatusOfBatchRequestRequest) XCOREOSTID(xCOREOSTID string) ApiGetStatusOfBatchRequestRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetStatusOfBatchRequestRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetStatusOfBatchRequestRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Unique id of batch request.
func (r ApiGetStatusOfBatchRequestRequest) BatchId(batchId string) ApiGetStatusOfBatchRequestRequest {
	r.batchId = &batchId
	return r
}

// Core-os user info
func (r ApiGetStatusOfBatchRequestRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetStatusOfBatchRequestRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetStatusOfBatchRequestRequest) Execute() (*ContainerBatchResponse, *http.Response, error) {
	return r.ApiService.GetStatusOfBatchRequestExecute(r)
}

/*
GetStatusOfBatchRequest Get the status of batch  request

**API to get the status of batch request.**
| HEADER/PATH/QUERY | DESCRIPTION | TYPE |
| - | - | - |
 | `X-COREOS-REQUEST-ID`*(header) | Unique Request ID. | string |
 | `X-COREOS-TID`*(header) | Tenant ID. | string |
 | `X-COREOS-ACCESS`*(header) | core-os access token. | string |
 | `containerType`*(path) | Type of container. | string |
 | `batchId`*(query) | Unique ID of batch request. | string |


 *This is required.

 **HTTP Status Code Summary**
  | Code | Description |
  | --- | ---- |
    | **200 - Ok** | Everything worked as expected. |
  | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
  | **401 - Unauthorized** | No valid API key provided. |
 | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerType Type of container
 @return ApiGetStatusOfBatchRequestRequest
*/
func (a *ContainerBatchProcessingApiService) GetStatusOfBatchRequest(ctx context.Context, containerType string) ApiGetStatusOfBatchRequestRequest {
	return ApiGetStatusOfBatchRequestRequest{
		ApiService: a,
		ctx: ctx,
		containerType: containerType,
	}
}

// Execute executes the request
//  @return ContainerBatchResponse
func (a *ContainerBatchProcessingApiService) GetStatusOfBatchRequestExecute(r ApiGetStatusOfBatchRequestRequest) (*ContainerBatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainerBatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerBatchProcessingApiService.GetStatusOfBatchRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerType}/batch/status"
	localVarPath = strings.Replace(localVarPath, "{"+"containerType"+"}", url.PathEscape(parameterToString(r.containerType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.batchId == nil {
		return localVarReturnValue, nil, reportError("batchId is required and must be specified")
	}
	if strlen(*r.batchId) < 1 {
		return localVarReturnValue, nil, reportError("batchId must have at least 1 elements")
	}
	if strlen(*r.batchId) > 64 {
		return localVarReturnValue, nil, reportError("batchId must have less than 64 elements")
	}

	localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatusOfBatchUploadRequestRequest struct {
	ctx context.Context
	ApiService *ContainerBatchProcessingApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerType string
	batchId *string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetStatusOfBatchUploadRequestRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetStatusOfBatchUploadRequestRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetStatusOfBatchUploadRequestRequest) XCOREOSTID(xCOREOSTID string) ApiGetStatusOfBatchUploadRequestRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetStatusOfBatchUploadRequestRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetStatusOfBatchUploadRequestRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Unique id of batch request.
func (r ApiGetStatusOfBatchUploadRequestRequest) BatchId(batchId string) ApiGetStatusOfBatchUploadRequestRequest {
	r.batchId = &batchId
	return r
}

// Core-os user info
func (r ApiGetStatusOfBatchUploadRequestRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetStatusOfBatchUploadRequestRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetStatusOfBatchUploadRequestRequest) Execute() (*ContainerBatchResponse, *http.Response, error) {
	return r.ApiService.GetStatusOfBatchUploadRequestExecute(r)
}

/*
GetStatusOfBatchUploadRequest Get the status of batch file request

**API to get the status of batch file request.**
| HEADER/PATH/QUERY | DESCRIPTION | TYPE |
 | - | - | - |
 | `X-COREOS-REQUEST-ID`*(header) | Unique Request ID. | string |
 | `X-COREOS-TID`*(header) | Tenant ID. | string |
 | `X-COREOS-ACCESS`*(header) | core-os access token. | string |
 | `containerType`*(path) | Type of container. | string |
 | `batchId`*(query) | Unique ID of batch request. | string |

 *This is required.

 **HTTP Status Code Summary**
 | Code | Description |
 | --- | ---- |
 | **200 - OK** | Everything worked as expected. |
 | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
 | **401 - Unauthorized** | No valid API key provided. |
  | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerType Type of container
 @return ApiGetStatusOfBatchUploadRequestRequest
*/
func (a *ContainerBatchProcessingApiService) GetStatusOfBatchUploadRequest(ctx context.Context, containerType string) ApiGetStatusOfBatchUploadRequestRequest {
	return ApiGetStatusOfBatchUploadRequestRequest{
		ApiService: a,
		ctx: ctx,
		containerType: containerType,
	}
}

// Execute executes the request
//  @return ContainerBatchResponse
func (a *ContainerBatchProcessingApiService) GetStatusOfBatchUploadRequestExecute(r ApiGetStatusOfBatchUploadRequestRequest) (*ContainerBatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainerBatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerBatchProcessingApiService.GetStatusOfBatchUploadRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerType}/batch/upload/status"
	localVarPath = strings.Replace(localVarPath, "{"+"containerType"+"}", url.PathEscape(parameterToString(r.containerType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.batchId == nil {
		return localVarReturnValue, nil, reportError("batchId is required and must be specified")
	}
	if strlen(*r.batchId) < 1 {
		return localVarReturnValue, nil, reportError("batchId must have at least 1 elements")
	}
	if strlen(*r.batchId) > 64 {
		return localVarReturnValue, nil, reportError("batchId must have less than 64 elements")
	}

	localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecordFileUploadCreateRequestRequest struct {
	ctx context.Context
	ApiService *ContainerBatchProcessingApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerType string
	xCOREOSORIGINTOKEN *string
	containerDataFileUpdateRequest *ContainerDataFileUpdateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiRecordFileUploadCreateRequestRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiRecordFileUploadCreateRequestRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiRecordFileUploadCreateRequestRequest) XCOREOSTID(xCOREOSTID string) ApiRecordFileUploadCreateRequestRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiRecordFileUploadCreateRequestRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiRecordFileUploadCreateRequestRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// App requesting for the attributes.
func (r ApiRecordFileUploadCreateRequestRequest) XCOREOSORIGINTOKEN(xCOREOSORIGINTOKEN string) ApiRecordFileUploadCreateRequestRequest {
	r.xCOREOSORIGINTOKEN = &xCOREOSORIGINTOKEN
	return r
}

// upload file request for container type.
func (r ApiRecordFileUploadCreateRequestRequest) ContainerDataFileUpdateRequest(containerDataFileUpdateRequest ContainerDataFileUpdateRequest) ApiRecordFileUploadCreateRequestRequest {
	r.containerDataFileUpdateRequest = &containerDataFileUpdateRequest
	return r
}

// Core-os user info
func (r ApiRecordFileUploadCreateRequestRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiRecordFileUploadCreateRequestRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiRecordFileUploadCreateRequestRequest) Execute() (*BatchSuccessResponse, *http.Response, error) {
	return r.ApiService.RecordFileUploadCreateRequestExecute(r)
}

/*
RecordFileUploadCreateRequest Perform create operation on container via file upload

**API to create container in batch through CSV file upload.**

| PARAMETER | DESCRIPTION | TYPE | Example |
 | - | - | - | - |
 | `file`* || string($binary) |
 | `callback` | Represents callback URL, which can be to notify status(success/failed) of API.| object | {url: "string", meta: {}} |

 *This is required.

 **HTTP Status Code Summary**
  | Code | Description |
  | --- | ---- |
   | **202 - Accepted** | Everything worked as expected. |
 | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
 | **401 - Unauthorized** | No valid API key provided. |
 | **404 - Not Found** | The requested resource doesn't exist. |
 | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerType Type of container
 @return ApiRecordFileUploadCreateRequestRequest
*/
func (a *ContainerBatchProcessingApiService) RecordFileUploadCreateRequest(ctx context.Context, containerType string) ApiRecordFileUploadCreateRequestRequest {
	return ApiRecordFileUploadCreateRequestRequest{
		ApiService: a,
		ctx: ctx,
		containerType: containerType,
	}
}

// Execute executes the request
//  @return BatchSuccessResponse
func (a *ContainerBatchProcessingApiService) RecordFileUploadCreateRequestExecute(r ApiRecordFileUploadCreateRequestRequest) (*BatchSuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchSuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerBatchProcessingApiService.RecordFileUploadCreateRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerType}/batch/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"containerType"+"}", url.PathEscape(parameterToString(r.containerType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSORIGINTOKEN == nil {
		return localVarReturnValue, nil, reportError("xCOREOSORIGINTOKEN is required and must be specified")
	}
	if r.containerDataFileUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("containerDataFileUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	localVarHeaderParams["X-COREOS-ORIGIN-TOKEN"] = parameterToString(*r.xCOREOSORIGINTOKEN, "")
	// body params
	localVarPostBody = r.containerDataFileUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecordFileUploadUpdateRequestRequest struct {
	ctx context.Context
	ApiService *ContainerBatchProcessingApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerType string
	xCOREOSORIGINTOKEN *string
	containerDataFileUpdateRequest *ContainerDataFileUpdateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiRecordFileUploadUpdateRequestRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiRecordFileUploadUpdateRequestRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiRecordFileUploadUpdateRequestRequest) XCOREOSTID(xCOREOSTID string) ApiRecordFileUploadUpdateRequestRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiRecordFileUploadUpdateRequestRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiRecordFileUploadUpdateRequestRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// App requesting for the attributes.
func (r ApiRecordFileUploadUpdateRequestRequest) XCOREOSORIGINTOKEN(xCOREOSORIGINTOKEN string) ApiRecordFileUploadUpdateRequestRequest {
	r.xCOREOSORIGINTOKEN = &xCOREOSORIGINTOKEN
	return r
}

// upload file request for container type.
func (r ApiRecordFileUploadUpdateRequestRequest) ContainerDataFileUpdateRequest(containerDataFileUpdateRequest ContainerDataFileUpdateRequest) ApiRecordFileUploadUpdateRequestRequest {
	r.containerDataFileUpdateRequest = &containerDataFileUpdateRequest
	return r
}

// Core-os user info
func (r ApiRecordFileUploadUpdateRequestRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiRecordFileUploadUpdateRequestRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiRecordFileUploadUpdateRequestRequest) Execute() (*BatchSuccessResponse, *http.Response, error) {
	return r.ApiService.RecordFileUploadUpdateRequestExecute(r)
}

/*
RecordFileUploadUpdateRequest Perform update operation on container via file upload

**API to update container in batch through CSV file upload.**
| PARAMETER | DESCRIPTION | TYPE | Example |
 | - | - | - | - |
 | `file`* || string($binary) |
 | `callback` | Represents callback URL, which can be to notify status(success/failed) of API.| object | {url: "string", meta: {}} |

 *This is required.

 **HTTP Status Code Summary**
  | Code | Description |
  | --- | ---- |
   | **202 - Accepted** | Everything worked as expected. |
 | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
 | **401 - Unauthorized** | No valid API key provided. |
 | **404 - Not Found** | The requested resource doesn't exist. |
 | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerType Type of container
 @return ApiRecordFileUploadUpdateRequestRequest
*/
func (a *ContainerBatchProcessingApiService) RecordFileUploadUpdateRequest(ctx context.Context, containerType string) ApiRecordFileUploadUpdateRequestRequest {
	return ApiRecordFileUploadUpdateRequestRequest{
		ApiService: a,
		ctx: ctx,
		containerType: containerType,
	}
}

// Execute executes the request
//  @return BatchSuccessResponse
func (a *ContainerBatchProcessingApiService) RecordFileUploadUpdateRequestExecute(r ApiRecordFileUploadUpdateRequestRequest) (*BatchSuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchSuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerBatchProcessingApiService.RecordFileUploadUpdateRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerType}/batch/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"containerType"+"}", url.PathEscape(parameterToString(r.containerType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSORIGINTOKEN == nil {
		return localVarReturnValue, nil, reportError("xCOREOSORIGINTOKEN is required and must be specified")
	}
	if r.containerDataFileUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("containerDataFileUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	localVarHeaderParams["X-COREOS-ORIGIN-TOKEN"] = parameterToString(*r.xCOREOSORIGINTOKEN, "")
	// body params
	localVarPostBody = r.containerDataFileUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
