/*
Container Service

**API documentation for Container Service**

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package container_client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ContainerTypeApiService ContainerTypeApi service
type ContainerTypeApiService service

type ApiCreateContainerTypeRequest struct {
	ctx context.Context
	ApiService *ContainerTypeApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerTypeCreateRequest *ContainerTypeCreateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiCreateContainerTypeRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiCreateContainerTypeRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiCreateContainerTypeRequest) XCOREOSTID(xCOREOSTID string) ApiCreateContainerTypeRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiCreateContainerTypeRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiCreateContainerTypeRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Create new container type
func (r ApiCreateContainerTypeRequest) ContainerTypeCreateRequest(containerTypeCreateRequest ContainerTypeCreateRequest) ApiCreateContainerTypeRequest {
	r.containerTypeCreateRequest = &containerTypeCreateRequest
	return r
}

// Core-os user info
func (r ApiCreateContainerTypeRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiCreateContainerTypeRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiCreateContainerTypeRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.CreateContainerTypeExecute(r)
}

/*
CreateContainerType  Create a new container type

**A container can be a bag or box or pallet etc. These different type of containers are known as container-types.** <br><br><mark>**Important**</mark>: <br><br>
     - Container types once created cannot be deleted. <br>
     - Once the Container type is created, its *name* and *isLeaf* property cannot be changed.
     <br><br>
    **Asynchronous API for creating a new *Container Type* by specifying the following parameters in the request body:**

   | PARAMETER | DESCRIPTION | TYPE | VALIDATION |
   | ---- | ---- | ----- | ---- |
   | `name`* | A unique name that represents a container of this container type. | string | **pattern:** It should match a through z or A through Z, inclusive (range).<br>**minLength:** 3 **maxLength:** 64 |
   | `isLeaf` | Defines whether this container-type will have actual physical items or not. Such types of containers are termed as leaf containers. | boolean | **default:** false |
   | `allowedParent` | Rules defining the allowed container types as parent of a container type. |
   | ㅤ↳`oneOf` | List of container types allowed as parent of this container type. | string | **minItems:** 1 **maxItems:** 16<br>**minLength:** 3 **maxLength:** 64 |
   | ㅤ↳`not` | List of container types not allowed as parent of this container type. | string | **minItems:** 1 **maxItems:** 16<br>**minLength:** 3 **maxLength:** 64 |
   | `callback` | Represents callback URL, which can be to notify status(success/failed) of API.| object | {url: "string", meta: {}} |
   *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **202 - Accepted** |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateContainerTypeRequest
*/
func (a *ContainerTypeApiService) CreateContainerType(ctx context.Context) ApiCreateContainerTypeRequest {
	return ApiCreateContainerTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerTypeApiService) CreateContainerTypeExecute(r ApiCreateContainerTypeRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeApiService.CreateContainerType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/container-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.containerTypeCreateRequest == nil {
		return localVarReturnValue, nil, reportError("containerTypeCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.containerTypeCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerTypeByIdRequest struct {
	ctx context.Context
	ApiService *ContainerTypeApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerTypeName string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetContainerTypeByIdRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetContainerTypeByIdRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetContainerTypeByIdRequest) XCOREOSTID(xCOREOSTID string) ApiGetContainerTypeByIdRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetContainerTypeByIdRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetContainerTypeByIdRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetContainerTypeByIdRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetContainerTypeByIdRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetContainerTypeByIdRequest) Execute() (*ContainerTypeResponse, *http.Response, error) {
	return r.ApiService.GetContainerTypeByIdExecute(r)
}

/*
GetContainerTypeById Get container type deatils by containerTypeName

**API to get the details of a container type by containerTypeName.**
<mark>**Important**</mark>: Core Attributes Configuration and State Machine Configuration of the container type are not included in the response.
 | HEADER/PATH | DESCRIPTION | TYPE |
 | ---- | ---- | ----- |
 | `X-COREOS-REQUEST-ID`*(header) | Unique request ID. | string |
 | `X-COREOS-TID`*(header) | Tenant ID. | string |
 | `X-COREOS-ACCESS`*(header) | Core-OS access token. | string |
 | `containerTypeName`*(path) | Unique Name of the Container Type. | string |
 *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **200 - OK** | Everything worked as expected. |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerTypeName A unique name to represent type of a container.
 @return ApiGetContainerTypeByIdRequest
*/
func (a *ContainerTypeApiService) GetContainerTypeById(ctx context.Context, containerTypeName string) ApiGetContainerTypeByIdRequest {
	return ApiGetContainerTypeByIdRequest{
		ApiService: a,
		ctx: ctx,
		containerTypeName: containerTypeName,
	}
}

// Execute executes the request
//  @return ContainerTypeResponse
func (a *ContainerTypeApiService) GetContainerTypeByIdExecute(r ApiGetContainerTypeByIdRequest) (*ContainerTypeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainerTypeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeApiService.GetContainerTypeById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/container-types/{containerTypeName}"
	localVarPath = strings.Replace(localVarPath, "{"+"containerTypeName"+"}", url.PathEscape(parameterToString(r.containerTypeName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if strlen(r.containerTypeName) < 3 {
		return localVarReturnValue, nil, reportError("containerTypeName must have at least 3 elements")
	}
	if strlen(r.containerTypeName) > 64 {
		return localVarReturnValue, nil, reportError("containerTypeName must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerTypesRequest struct {
	ctx context.Context
	ApiService *ContainerTypeApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	xCOREOSUSERINFO *string
	limit *int32
	offset *int32
	select_ *[]string
	query *ContainerTypeFilterQuery
	sortKey *string
	sortBy *SortBy
}

// Unique request id.
func (r ApiGetContainerTypesRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetContainerTypesRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetContainerTypesRequest) XCOREOSTID(xCOREOSTID string) ApiGetContainerTypesRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetContainerTypesRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetContainerTypesRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetContainerTypesRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetContainerTypesRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

// Number of items to return.
func (r ApiGetContainerTypesRequest) Limit(limit int32) ApiGetContainerTypesRequest {
	r.limit = &limit
	return r
}

// Number of items to skip from start.
func (r ApiGetContainerTypesRequest) Offset(offset int32) ApiGetContainerTypesRequest {
	r.offset = &offset
	return r
}

// Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response.
func (r ApiGetContainerTypesRequest) Select_(select_ []string) ApiGetContainerTypesRequest {
	r.select_ = &select_
	return r
}

// Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)
func (r ApiGetContainerTypesRequest) Query(query ContainerTypeFilterQuery) ApiGetContainerTypesRequest {
	r.query = &query
	return r
}

// key to be used for sorting data
func (r ApiGetContainerTypesRequest) SortKey(sortKey string) ApiGetContainerTypesRequest {
	r.sortKey = &sortKey
	return r
}

// fetching data in ascending(asc) or descending(desc) order.
func (r ApiGetContainerTypesRequest) SortBy(sortBy SortBy) ApiGetContainerTypesRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetContainerTypesRequest) Execute() (*ContainerTypesResponse, *http.Response, error) {
	return r.ApiService.GetContainerTypesExecute(r)
}

/*
GetContainerTypes Fetch container type details based on the filters passed

**API to get the list of all container types and their basic details.**

<mark>**Important**</mark>: Core Attributes Configuration and State Machine Configuration of container types are not included in the response.
| HEADER/QUERY PARAMETER | DESCRIPTION | TYPE | VALIDATION |
 | ---- | ---- | ----- | ---- |
 | `X-COREOS-REQUEST-ID`*(header) | Unique request ID. | string |
 | `X-COREOS-TID`*(header) | Tenant ID. | string |
 | `X-COREOS-ACCESS`*(header) | Core-OS access token. | string |
 | `limit`(query) | Number of items to return. | integer | **Default value:** 50 |
 | `offset`(query) | The number of items to skip from the start. | integer | **Default value:** 0 |
 | `select`(query) | Specifies the list of attributes to be included in the response. If not specified, all attributes are included in the response. | array[string] | **Available values:** name, isSystem, isActive, allowedOwner, ttl |
 | `query`(query) | Query criteria. | object | Refer following links for more details:<br> <br> ㅤ1. [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html) <br> ㅤ2. [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)<br> ㅤ3. [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)<br> ㅤ4. [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)<br> ㅤ5. [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)<br> ㅤ6. [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)<br> ㅤ7. [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html) |
 | `sortKey`(query) | Key to be used for sorting data. | string | **Default value:** createdAt |
 | `sortBy`(query) | Fetching data in ascending (asc) or descending (desc) order. | string | **Default value:** desc<br>**Available values**: desc, asc |
 *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **200 - OK** | Everything worked as expected. |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetContainerTypesRequest
*/
func (a *ContainerTypeApiService) GetContainerTypes(ctx context.Context) ApiGetContainerTypesRequest {
	return ApiGetContainerTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContainerTypesResponse
func (a *ContainerTypeApiService) GetContainerTypesExecute(r ApiGetContainerTypesRequest) (*ContainerTypesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainerTypesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeApiService.GetContainerTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/container-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("select", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("select", parameterToString(t, "multi"))
		}
	}
	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.sortKey != nil {
		localVarQueryParams.Add("sortKey", parameterToString(*r.sortKey, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateContainerTypeRequest struct {
	ctx context.Context
	ApiService *ContainerTypeApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerTypeName string
	containerTypeUpdateRequest *ContainerTypeUpdateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiUpdateContainerTypeRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiUpdateContainerTypeRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiUpdateContainerTypeRequest) XCOREOSTID(xCOREOSTID string) ApiUpdateContainerTypeRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiUpdateContainerTypeRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiUpdateContainerTypeRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Update Container type configuration
func (r ApiUpdateContainerTypeRequest) ContainerTypeUpdateRequest(containerTypeUpdateRequest ContainerTypeUpdateRequest) ApiUpdateContainerTypeRequest {
	r.containerTypeUpdateRequest = &containerTypeUpdateRequest
	return r
}

// Core-os user info
func (r ApiUpdateContainerTypeRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiUpdateContainerTypeRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiUpdateContainerTypeRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UpdateContainerTypeExecute(r)
}

/*
UpdateContainerType Update container type basic deatils

**API to update basic configuration of a container type specified by ContainerTypeName.** <br><br><mark>**Important**</mark>: Core Attributes Configuration and State Machine Configuration of the container type cannot be updated using this API.
| PARAMETER | DESCRIPTION | TYPE | VALIDATION |
   | ---- | ---- | ----- | ---- |
   | `allowedParent`* | Rules defining the allowed/disallowed container types (singular name) as parent of a container type. |
   | ㅤ↳`oneOf` | List of container types allowed as parent of this container type. | string | **minItems:** 1 **maxItems:** 16<br>**minLength:** 3 **maxLength:** 64 |
   | ㅤ↳`not` | List of container types not allowed as parent of this container type. | string | **minItems:** 1 **maxItems:** 16<br>**minLength:** 3 **maxLength:** 64 |
   | `callback` | Represents callback URL, which can be to notify status(success/failed) of API.| object | {url: "string", meta: {}} |
   *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **202 - Accepted** |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerTypeName A unique name to represent type of a container.
 @return ApiUpdateContainerTypeRequest
*/
func (a *ContainerTypeApiService) UpdateContainerType(ctx context.Context, containerTypeName string) ApiUpdateContainerTypeRequest {
	return ApiUpdateContainerTypeRequest{
		ApiService: a,
		ctx: ctx,
		containerTypeName: containerTypeName,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerTypeApiService) UpdateContainerTypeExecute(r ApiUpdateContainerTypeRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeApiService.UpdateContainerType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/container-types/{containerTypeName}"
	localVarPath = strings.Replace(localVarPath, "{"+"containerTypeName"+"}", url.PathEscape(parameterToString(r.containerTypeName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if strlen(r.containerTypeName) < 3 {
		return localVarReturnValue, nil, reportError("containerTypeName must have at least 3 elements")
	}
	if strlen(r.containerTypeName) > 64 {
		return localVarReturnValue, nil, reportError("containerTypeName must have less than 64 elements")
	}
	if r.containerTypeUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("containerTypeUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.containerTypeUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
