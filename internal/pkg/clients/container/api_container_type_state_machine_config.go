/*
Container Service

**API documentation for Container Service**

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package container_client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ContainerTypeStateMachineConfigApiService ContainerTypeStateMachineConfigApi service
type ContainerTypeStateMachineConfigApiService service

type ApiCreateEventsRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	eventCreateRequest *EventCreateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiCreateEventsRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiCreateEventsRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiCreateEventsRequest) XCOREOSTID(xCOREOSTID string) ApiCreateEventsRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiCreateEventsRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiCreateEventsRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Create new State Machine Event.
func (r ApiCreateEventsRequest) EventCreateRequest(eventCreateRequest EventCreateRequest) ApiCreateEventsRequest {
	r.eventCreateRequest = &eventCreateRequest
	return r
}

// Core-os user info
func (r ApiCreateEventsRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiCreateEventsRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiCreateEventsRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.CreateEventsExecute(r)
}

/*
CreateEvents Create events for a container-type

**This API is for create events based on given details.**

 **HTTP Status Code Summary**
 | Code | Description |
 | --- | ---- |
 | **200 - OK** | Everything worked as expected. |
  | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
  | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEventsRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) CreateEvents(ctx context.Context) ApiCreateEventsRequest {
	return ApiCreateEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) CreateEventsExecute(r ApiCreateEventsRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.CreateEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.eventCreateRequest == nil {
		return localVarReturnValue, nil, reportError("eventCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.eventCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReasonRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	reasonCreateRequest *ReasonCreateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiCreateReasonRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiCreateReasonRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiCreateReasonRequest) XCOREOSTID(xCOREOSTID string) ApiCreateReasonRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiCreateReasonRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiCreateReasonRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

func (r ApiCreateReasonRequest) ReasonCreateRequest(reasonCreateRequest ReasonCreateRequest) ApiCreateReasonRequest {
	r.reasonCreateRequest = &reasonCreateRequest
	return r
}

// Core-os user info
func (r ApiCreateReasonRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiCreateReasonRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiCreateReasonRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.CreateReasonExecute(r)
}

/*
CreateReason API to get list of orphan event codes (not associated with any reason code).

**This API is for create events based on given details.**

 **HTTP Status Code Summary**
 | Code | Description |
 | --- | ---- |
 | **200 - OK** | Everything worked as expected. |
  | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
  | **401 - Unauthorized** | No valid API key provided. |
  | **404 - Not Found** | The requested resource doesn't exist. |
  | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateReasonRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) CreateReason(ctx context.Context) ApiCreateReasonRequest {
	return ApiCreateReasonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) CreateReasonExecute(r ApiCreateReasonRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.CreateReason")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/reasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.reasonCreateRequest == nil {
		return localVarReturnValue, nil, reportError("reasonCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.reasonCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllEventsRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	xCOREOSUSERINFO *string
	limit *int32
	offset *int32
}

// Unique request id.
func (r ApiGetAllEventsRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetAllEventsRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetAllEventsRequest) XCOREOSTID(xCOREOSTID string) ApiGetAllEventsRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetAllEventsRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetAllEventsRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetAllEventsRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetAllEventsRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

// Number of items to return.
func (r ApiGetAllEventsRequest) Limit(limit int32) ApiGetAllEventsRequest {
	r.limit = &limit
	return r
}

// Number of items to skip from start.
func (r ApiGetAllEventsRequest) Offset(offset int32) ApiGetAllEventsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetAllEventsRequest) Execute() (*EventsAllSuccessResponse, *http.Response, error) {
	return r.ApiService.GetAllEventsExecute(r)
}

/*
GetAllEvents Get all events

**This API will get all event with given event details.**

 **HTTP Status Code Summary**
   | Code | Description |
   | --- | ---- |
   | **200 - OK** | Everything worked as expected. |
    | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
    | **401 - Unauthorized** | No valid API key provided. |
    | **404 - Not Found** | The requested resource doesn't exist. |
    | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllEventsRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) GetAllEvents(ctx context.Context) ApiGetAllEventsRequest {
	return ApiGetAllEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventsAllSuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) GetAllEventsExecute(r ApiGetAllEventsRequest) (*EventsAllSuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventsAllSuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.GetAllEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllReasonsRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	xCOREOSUSERINFO *string
	limit *int32
	offset *int32
}

// Unique request id.
func (r ApiGetAllReasonsRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetAllReasonsRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetAllReasonsRequest) XCOREOSTID(xCOREOSTID string) ApiGetAllReasonsRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetAllReasonsRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetAllReasonsRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetAllReasonsRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetAllReasonsRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

// Number of items to return.
func (r ApiGetAllReasonsRequest) Limit(limit int32) ApiGetAllReasonsRequest {
	r.limit = &limit
	return r
}

// Number of items to skip from start.
func (r ApiGetAllReasonsRequest) Offset(offset int32) ApiGetAllReasonsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetAllReasonsRequest) Execute() (*ReasonsAllSuccessResponse, *http.Response, error) {
	return r.ApiService.GetAllReasonsExecute(r)
}

/*
GetAllReasons Get all reasons

**This API will get all reason.**

 **HTTP Status Code Summary**
   | Code | Description |
   | --- | ---- |
   | **200 - OK** | Everything worked as expected. |
    | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
    | **401 - Unauthorized** | No valid API key provided. |
    | **404 - Not Found** | The requested resource doesn't exist. |
    | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllReasonsRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) GetAllReasons(ctx context.Context) ApiGetAllReasonsRequest {
	return ApiGetAllReasonsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReasonsAllSuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) GetAllReasonsExecute(r ApiGetAllReasonsRequest) (*ReasonsAllSuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReasonsAllSuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.GetAllReasons")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/reasons"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	eventCode string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetEventRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetEventRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetEventRequest) XCOREOSTID(xCOREOSTID string) ApiGetEventRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetEventRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetEventRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetEventRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetEventRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetEventRequest) Execute() (*EventsSuccessResponse, *http.Response, error) {
	return r.ApiService.GetEventExecute(r)
}

/*
GetEvent Get events for a container-type

**This API is for create events based on given details.**

 **HTTP Status Code Summary**
 | Code | Description |
 | --- | ---- |
 | **200 - OK** | Everything worked as expected. |
  | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
  | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventCode Code for an Event.
 @return ApiGetEventRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) GetEvent(ctx context.Context, eventCode string) ApiGetEventRequest {
	return ApiGetEventRequest{
		ApiService: a,
		ctx: ctx,
		eventCode: eventCode,
	}
}

// Execute executes the request
//  @return EventsSuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) GetEventExecute(r ApiGetEventRequest) (*EventsSuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventsSuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.GetEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/events/{eventCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventCode"+"}", url.PathEscape(parameterToString(r.eventCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrphanEventRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetOrphanEventRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetOrphanEventRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetOrphanEventRequest) XCOREOSTID(xCOREOSTID string) ApiGetOrphanEventRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetOrphanEventRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetOrphanEventRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetOrphanEventRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetOrphanEventRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetOrphanEventRequest) Execute() (*EventsOrphanResponse, *http.Response, error) {
	return r.ApiService.GetOrphanEventExecute(r)
}

/*
GetOrphanEvent API to get list of orphan event codes (not associated with any reason code).

**This API is for create events based on given details.**

 **HTTP Status Code Summary**
 | Code | Description |
 | --- | ---- |
 | **200 - OK** | Everything worked as expected. |
  | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
  | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrphanEventRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) GetOrphanEvent(ctx context.Context) ApiGetOrphanEventRequest {
	return ApiGetOrphanEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventsOrphanResponse
func (a *ContainerTypeStateMachineConfigApiService) GetOrphanEventExecute(r ApiGetOrphanEventRequest) (*EventsOrphanResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventsOrphanResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.GetOrphanEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/events/orphan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrphanReasonRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetOrphanReasonRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetOrphanReasonRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetOrphanReasonRequest) XCOREOSTID(xCOREOSTID string) ApiGetOrphanReasonRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetOrphanReasonRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetOrphanReasonRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetOrphanReasonRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetOrphanReasonRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetOrphanReasonRequest) Execute() (*ReasonsOrphanResponse, *http.Response, error) {
	return r.ApiService.GetOrphanReasonExecute(r)
}

/*
GetOrphanReason API to get list of orphan event codes (not associated with any reason code).

**This API is for create events based on given details.**

 **HTTP Status Code Summary**
 | Code | Description |
 | --- | ---- |
 | **200 - OK** | Everything worked as expected. |
  | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
  | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrphanReasonRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) GetOrphanReason(ctx context.Context) ApiGetOrphanReasonRequest {
	return ApiGetOrphanReasonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReasonsOrphanResponse
func (a *ContainerTypeStateMachineConfigApiService) GetOrphanReasonExecute(r ApiGetOrphanReasonRequest) (*ReasonsOrphanResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReasonsOrphanResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.GetOrphanReason")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/reason/orphan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReasonRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	reasonCode string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetReasonRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetReasonRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetReasonRequest) XCOREOSTID(xCOREOSTID string) ApiGetReasonRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetReasonRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetReasonRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetReasonRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetReasonRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetReasonRequest) Execute() (*ReasonsSuccessResponse, *http.Response, error) {
	return r.ApiService.GetReasonExecute(r)
}

/*
GetReason API to get list of orphan event codes (not associated with any reason code).

**This API is for create events based on given details.**

 **HTTP Status Code Summary**
 | Code | Description |
 | --- | ---- |
 | **200 - OK** | Everything worked as expected. |
  | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
  | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reasonCode Code for a Reason.
 @return ApiGetReasonRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) GetReason(ctx context.Context, reasonCode string) ApiGetReasonRequest {
	return ApiGetReasonRequest{
		ApiService: a,
		ctx: ctx,
		reasonCode: reasonCode,
	}
}

// Execute executes the request
//  @return ReasonsSuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) GetReasonExecute(r ApiGetReasonRequest) (*ReasonsSuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReasonsSuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.GetReason")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/reasons/{reasonCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"reasonCode"+"}", url.PathEscape(parameterToString(r.reasonCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStateMachineRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerTypeName string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetStateMachineRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetStateMachineRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetStateMachineRequest) XCOREOSTID(xCOREOSTID string) ApiGetStateMachineRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetStateMachineRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetStateMachineRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetStateMachineRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetStateMachineRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetStateMachineRequest) Execute() (*StateMachineConfigResponse, *http.Response, error) {
	return r.ApiService.GetStateMachineExecute(r)
}

/*
GetStateMachine  Get state machine configuration of container type

**API to get the current state-machine configurtion (states, sub-states, and state transition rules) of a container type specified by the containerTypeName.**
 | HEADER/PATH | DESCRIPTION | TYPE |
 | ---- | ---- | ----- |
 | `X-COREOS-REQUEST-ID`*(header) | Unique request ID. | string |
 | `X-COREOS-TID`*(header) | Tenant ID. | string |
 | `X-COREOS-ACCESS`*(header) | Core-OS access token. | string |
 | `containerTypeName`*(path) | Unique Name of the Container Type. | string |
 *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **200 - OK** | Everything worked as expected. |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong.. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerTypeName A unique name to represent type of a container.
 @return ApiGetStateMachineRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) GetStateMachine(ctx context.Context, containerTypeName string) ApiGetStateMachineRequest {
	return ApiGetStateMachineRequest{
		ApiService: a,
		ctx: ctx,
		containerTypeName: containerTypeName,
	}
}

// Execute executes the request
//  @return StateMachineConfigResponse
func (a *ContainerTypeStateMachineConfigApiService) GetStateMachineExecute(r ApiGetStateMachineRequest) (*StateMachineConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StateMachineConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.GetStateMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/container-types/{containerTypeName}/config/state-machine"
	localVarPath = strings.Replace(localVarPath, "{"+"containerTypeName"+"}", url.PathEscape(parameterToString(r.containerTypeName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if strlen(r.containerTypeName) < 3 {
		return localVarReturnValue, nil, reportError("containerTypeName must have at least 3 elements")
	}
	if strlen(r.containerTypeName) > 64 {
		return localVarReturnValue, nil, reportError("containerTypeName must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEntityRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	entityCode string
	entityUpdateRequest *EntityUpdateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiUpdateEntityRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiUpdateEntityRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiUpdateEntityRequest) XCOREOSTID(xCOREOSTID string) ApiUpdateEntityRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiUpdateEntityRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiUpdateEntityRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

func (r ApiUpdateEntityRequest) EntityUpdateRequest(entityUpdateRequest EntityUpdateRequest) ApiUpdateEntityRequest {
	r.entityUpdateRequest = &entityUpdateRequest
	return r
}

// Core-os user info
func (r ApiUpdateEntityRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiUpdateEntityRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiUpdateEntityRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UpdateEntityExecute(r)
}

/*
UpdateEntity Update an Entity

**This API will update an entity. Events mentioned in the events list will be replaced for the entity**

 **HTTP Status Code Summary**
   | Code | Description |
   | --- | ---- |
   | **200 - OK** | Everything worked as expected. |
    | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
    | **401 - Unauthorized** | No valid API key provided. |
    | **404 - Not Found** | The requested resource doesn't exist. |
    | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entityCode Code of an entity.
 @return ApiUpdateEntityRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) UpdateEntity(ctx context.Context, entityCode string) ApiUpdateEntityRequest {
	return ApiUpdateEntityRequest{
		ApiService: a,
		ctx: ctx,
		entityCode: entityCode,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) UpdateEntityExecute(r ApiUpdateEntityRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.UpdateEntity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/entities/{entityCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"entityCode"+"}", url.PathEscape(parameterToString(r.entityCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.entityUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("entityUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.entityUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEventRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	eventCode string
	eventUpdateRequest *EventUpdateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiUpdateEventRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiUpdateEventRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiUpdateEventRequest) XCOREOSTID(xCOREOSTID string) ApiUpdateEventRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiUpdateEventRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiUpdateEventRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Create new State Machine Event.
func (r ApiUpdateEventRequest) EventUpdateRequest(eventUpdateRequest EventUpdateRequest) ApiUpdateEventRequest {
	r.eventUpdateRequest = &eventUpdateRequest
	return r
}

// Core-os user info
func (r ApiUpdateEventRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiUpdateEventRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiUpdateEventRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UpdateEventExecute(r)
}

/*
UpdateEvent Update events for a container-type

**This API is for create events based on given details.**

 **HTTP Status Code Summary**
 | Code | Description |
 | --- | ---- |
 | **200 - OK** | Everything worked as expected. |
  | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
  | **401 - Unauthorized** | No valid API key provided. |
  | **404 - Not Found** | The requested resource doesn't exist.
  | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventCode Code for an Event.
 @return ApiUpdateEventRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) UpdateEvent(ctx context.Context, eventCode string) ApiUpdateEventRequest {
	return ApiUpdateEventRequest{
		ApiService: a,
		ctx: ctx,
		eventCode: eventCode,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) UpdateEventExecute(r ApiUpdateEventRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.UpdateEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/events/{eventCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventCode"+"}", url.PathEscape(parameterToString(r.eventCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.eventUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("eventUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.eventUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateReasonRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	reasonCode string
	reasonUpdateRequest *ReasonUpdateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiUpdateReasonRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiUpdateReasonRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiUpdateReasonRequest) XCOREOSTID(xCOREOSTID string) ApiUpdateReasonRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiUpdateReasonRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiUpdateReasonRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

func (r ApiUpdateReasonRequest) ReasonUpdateRequest(reasonUpdateRequest ReasonUpdateRequest) ApiUpdateReasonRequest {
	r.reasonUpdateRequest = &reasonUpdateRequest
	return r
}

// Core-os user info
func (r ApiUpdateReasonRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiUpdateReasonRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiUpdateReasonRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UpdateReasonExecute(r)
}

/*
UpdateReason API to get list of orphan event codes (not associated with any reason code).

**This API is for create events based on given details.**

 **HTTP Status Code Summary**
 | Code | Description |
 | --- | ---- |
 | **200 - OK** | Everything worked as expected. |
  | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
  | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Errors** | Something went wrong on our end. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reasonCode Code for a Reason.
 @return ApiUpdateReasonRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) UpdateReason(ctx context.Context, reasonCode string) ApiUpdateReasonRequest {
	return ApiUpdateReasonRequest{
		ApiService: a,
		ctx: ctx,
		reasonCode: reasonCode,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) UpdateReasonExecute(r ApiUpdateReasonRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.UpdateReason")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/state-machine/reasons/{reasonCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"reasonCode"+"}", url.PathEscape(parameterToString(r.reasonCode, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.reasonUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("reasonUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.reasonUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateStateMachineRequest struct {
	ctx context.Context
	ApiService *ContainerTypeStateMachineConfigApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerTypeName string
	stateMachineUpdateRequest *StateMachineUpdateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiUpdateStateMachineRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiUpdateStateMachineRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiUpdateStateMachineRequest) XCOREOSTID(xCOREOSTID string) ApiUpdateStateMachineRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiUpdateStateMachineRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiUpdateStateMachineRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Update container type state machine
func (r ApiUpdateStateMachineRequest) StateMachineUpdateRequest(stateMachineUpdateRequest StateMachineUpdateRequest) ApiUpdateStateMachineRequest {
	r.stateMachineUpdateRequest = &stateMachineUpdateRequest
	return r
}

// Core-os user info
func (r ApiUpdateStateMachineRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiUpdateStateMachineRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiUpdateStateMachineRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UpdateStateMachineExecute(r)
}

/*
UpdateStateMachine  Update state machine configuration of container type

**This API is for updating the current state-machine configuration (states, sub-states, and state transition rules) of a container type specified by the containerTypeName.**

  - **Events** - Represents array of Events. An event contains event name, event data,if any.
    - **Event Name** - Represents name of the event for state transition.
    - **Event data** - data expected with the event and validation, if any, for the event data.
  - **States** List of main states with its substates and transitions.

<mark>**Important**</mark>: The state machine cannot be partially updated. Moreover, for each non-terminal sub-state, at least one state transition rule is expected.
| PARAMETER | DESCRIPTION | TYPE | VALIDATION |
   | ---- | ---- | ----- | ---- |
   | `events`* | Represents an array of Events. An event contains event name, event data, if any. |
   | `event`* | Represents name of the event for state transition. | string | **Example**: createdToOpened |
   | `eventType` | Specifies event is transitional or not. <br>**TRANSITIONAL**- Transitonal event is an event that upon invocation it will change the state of the container.<br>**NON_TRANSITIONAL**- Transitonal event is an event that upon invocation it will not change the state of the container. | string | **default**: TRANSITIONAL<br>**Enum**: [ TRANSITIONAL, NON_TRANSITIONAL ] |
   | `eventData` | Data expected with the event and validation, if any, for the event data. |
   | `name`* | Name of validation keys of an event. | string | **minLength**: 1 **maxLength**: 32 |
   | `type` | Event data type | string | **Enum**: [string, number, boolean, object, array] |
   | `validation` | Validation rules for a string or number value. |
   | `range` | Field to specify the range that the attribute value must lie. In case of "string" data type, range will be the length of string value. |
   | `min` | The min value, inclusive. | number |
   | `max` | The max value, inclusive. | number |
   | `regex` | Regex that the data should match. | string | **minLength**: 1 **maxLength**: 512 |
   | `valueOneOf` | Enum of accepted values. | | **minItems**: 1 **maxItems**: 16 |
   | `required` | Specifies whether the value is required or optional. | boolean | **Default**: false |
   | `blocking` | Specifies whether we need to block the event transition in case the attribute validation is failed or not. | boolean | **Default**: true |
   | `states`* | List of main states with its sub-states and transitions. |
   | `created`* | State created. |
   | `name`* | Name of the state. | string |
   | `defaultSubstate`* | Represents default substate for this state. | string |
   | `substates`* | | | **minItems**: 1 |
   | `name`* | Name of the sub-state. | string | **minLength**: 3 **maxLength**: 32 |
   | `transitions`* | Represents an array of transition rules for this substate. Transition Rule for this state. Contains events and the destination state. |
   | `event`* | Represents name of the event for state transition. | string | **minLength**: 3 **maxLength**: 32 |
   | `destination`* | Name of the main state and its sub-state. | string | **Example**: created<br>**minLength**: 3 **maxLength**: 32 |
   | `ttl` | Time to live associated with each state of a container. |
   | `time`* | Time to live is associated with the state of a container. | string | **pattern**: Time string in days, hours, minutes, and seconds.<br>**minLength**: 2<br>**Example** - 30m, 1d 12h, 1d 12h 30m 45s etc.|
   | `destination`* | Represents destination state to which this instance should be transitioned to after ttl expiry. | string |
   | `callback` | Represents callback URL, which can be called to get any info about state transition of a container or its terminal ttl expiry. | string | A valid URL. |
   | `opened`* | It signifies readiness of container to begin containerization process.
   | `name`* | Name of the state. | string |
   | `defaultSubstate`* | Represents default substate for this state. | string |
   | `substates`* | | | **minItems**: 1 |
   | `name`* | Name of the sub-state. | string | **minLength**: 3 **maxLength**: 32 |
   | `transitions`* | Represents an array of transition rules for this substate. Transition Rule for this state. Contains events and the destination state. |
   | `event`* | Represents name of the event for state transition. | string | **minLength**: 3 **maxLength**: 32 |
   | `destination`* | Name of the main state and its sub-state. | string | **Example**: created<br>**minLength**: 3 **maxLength**: 32 |
   | `ttl` | Time to live associated with each state of a container. |
   | `time`* | Time to live is associated with the state of a container. | string | **pattern**: Time string in days, hours, minutes, and seconds.<br>**minLength**: 2<br>**Example** - 30m, 1d 12h, 1d 12h 30m 45s etc.|
   | `destination`* | Represents destination state to which this instance should be transitioned to after ttl expiry. | string |
   | `callback` | Represents callback URL, which can be called to get any info about state transition of a container or its terminal ttl expiry. | string | A valid URL. |
   | `closed`* | It signifies the termination of containerization process. |
   | `name`* | Name of the state. | string |
   | `defaultSubstate`* | Represents default substate for this state. | string |
   | `substates`* | | | **minItems**: 1 |
   | `name`* | Name of the sub-state. | string | **minLength**: 3 **maxLength**: 32 |
   | `transitions`* | Represents an array of transition rules for this substate. Transition Rule for this state. Contains events and the destination state. |
   | `event`* | Represents name of the event for state transition. | string | **minLength**: 3 **maxLength**: 32 |
   | `destination`* | Name of the main state and its sub-state. | string | **Example**: created<br>**minLength**: 3 **maxLength**: 32 |
   | `ttl` | Time to live associated with each state of a container. |
   | `time`* | Time to live is associated with the state of a container. | string | **pattern**: Time string in days, hours, minutes, and seconds.<br>**minLength**: 2<br>**Example** - 30m, 1d 12h, 1d 12h 30m 45s etc.|
   | `destination`* | Represents destination state to which this instance should be transitioned to after ttl expiry. | string |
   | `callback` | Represents callback URL, which can be called to get any info about state transition of a container or its terminal ttl expiry. | string | A valid URL. |
   | `completed`* | End of the lifecycle of a container. |
   | `name`* | Name of the state. | string |
   | `defaultSubstate`* | Represents default substate for this state. | string |
   | `substates`* | | | **minItems**: 1 |
   | `name`* | Name of the sub-state. | string | **minLength**: 3 **maxLength**: 32 |
   | `transitions`* | Represents an array of transition rules for this substate. Transition Rule for this state. Contains events and the destination state. |
   | `event`* | Represents name of the event for state transition. | string | **minLength**: 3 **maxLength**: 32 |
   | `destination`* | Name of the main state and its sub-state. | string | **Example**: created<br>**minLength**: 3 **maxLength**: 32 |
   | `ttl` | Time to live associated with each state of a container. |
   | `time`* | Time to live is associated with the state of a container. | string | **pattern**: Time string in days, hours, minutes, and seconds.<br>**minLength**: 2<br>**Example** - 30m, 1d 12h, 1d 12h 30m 45s etc.|
   | `destination`* | Represents destination state to which this instance should be transitioned to after ttl expiry. | string |
   | `callback` | Represents callback URL, which can be called to get any info about state transition of a container or its terminal ttl expiry. | string | A valid URL. |
   | `terminalStates` | Terminal state. | sting |
   | `terminalTTL`* | Specifies the time to live for a data entry in the database. Specified for a tenant. | string | **Default**: 30d **Example**: 10d5h3m0s <br>**minLength**: 2 **maxLength**: 12 |
   | `callback` | Represents callback URL, which can be called to get any info about state transition of a container or its terminal ttl expiry. | string | A valid URL. |
   *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **200 - OK** | Everything worked as expected. |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong.. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerTypeName A unique name to represent type of a container.
 @return ApiUpdateStateMachineRequest
*/
func (a *ContainerTypeStateMachineConfigApiService) UpdateStateMachine(ctx context.Context, containerTypeName string) ApiUpdateStateMachineRequest {
	return ApiUpdateStateMachineRequest{
		ApiService: a,
		ctx: ctx,
		containerTypeName: containerTypeName,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerTypeStateMachineConfigApiService) UpdateStateMachineExecute(r ApiUpdateStateMachineRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerTypeStateMachineConfigApiService.UpdateStateMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/container-types/{containerTypeName}/config/state-machine"
	localVarPath = strings.Replace(localVarPath, "{"+"containerTypeName"+"}", url.PathEscape(parameterToString(r.containerTypeName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if strlen(r.containerTypeName) < 3 {
		return localVarReturnValue, nil, reportError("containerTypeName must have at least 3 elements")
	}
	if strlen(r.containerTypeName) > 64 {
		return localVarReturnValue, nil, reportError("containerTypeName must have less than 64 elements")
	}
	if r.stateMachineUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("stateMachineUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.stateMachineUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
