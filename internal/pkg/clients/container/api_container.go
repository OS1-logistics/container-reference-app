/*
Container Service

**API documentation for Container Service**

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package container_client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ContainerApiService ContainerApi service
type ContainerApiService service

type ApiContainerizeContainerByIdRequest struct {
	ctx context.Context
	ApiService *ContainerApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerId string
	parentIdRequest *ParentIdRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiContainerizeContainerByIdRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiContainerizeContainerByIdRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiContainerizeContainerByIdRequest) XCOREOSTID(xCOREOSTID string) ApiContainerizeContainerByIdRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiContainerizeContainerByIdRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiContainerizeContainerByIdRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// parent id
func (r ApiContainerizeContainerByIdRequest) ParentIdRequest(parentIdRequest ParentIdRequest) ApiContainerizeContainerByIdRequest {
	r.parentIdRequest = &parentIdRequest
	return r
}

// Core-os user info
func (r ApiContainerizeContainerByIdRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiContainerizeContainerByIdRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiContainerizeContainerByIdRequest) Execute() (*ChildContainerResponse, *http.Response, error) {
	return r.ApiService.ContainerizeContainerByIdExecute(r)
}

/*
ContainerizeContainerById containerization/decontainerization of the container

**Grouping together container into a container. The container that goes inside another container is said to be containerized.**
- **containerId** - The child container ID that needs to be add in parent container.
- **parentId** - The parent container ID that needs to be add as parent of a container.
          
- **action** - field to represent action to be performed on the container.


 | PARAMETER | DESCRIPTION | TYPE | VALIDATION |
 | --- | --- | --- | --- |
 | `parentId`* | Field to represent container ID of the parent container. During the containerization process, this value is assigned to represent which container contains this container. | string | **Example**- box:9c9b1138-7cdd-11eb-9439-0242ac130002 |
 | `action`* | field to represent action to be performed on the container.field to represent action to be performed on the container.
 | `callback` | Represents callback URL, which can be to notify status(success/failed) of API. | string | A valid URL. |
*This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **202 - Accepted** |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong.. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerId Unique id of Container
 @return ApiContainerizeContainerByIdRequest
*/
func (a *ContainerApiService) ContainerizeContainerById(ctx context.Context, containerId string) ApiContainerizeContainerByIdRequest {
	return ApiContainerizeContainerByIdRequest{
		ApiService: a,
		ctx: ctx,
		containerId: containerId,
	}
}

// Execute executes the request
//  @return ChildContainerResponse
func (a *ContainerApiService) ContainerizeContainerByIdExecute(r ApiContainerizeContainerByIdRequest) (*ChildContainerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChildContainerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerApiService.ContainerizeContainerById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerId}/child"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(parameterToString(r.containerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.parentIdRequest == nil {
		return localVarReturnValue, nil, reportError("parentIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	// body params
	localVarPostBody = r.parentIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContainerRequest struct {
	ctx context.Context
	ApiService *ContainerApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerId string
	xCOREOSORIGINTOKEN *string
	containerCreateRequest *ContainerCreateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiCreateContainerRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiCreateContainerRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiCreateContainerRequest) XCOREOSTID(xCOREOSTID string) ApiCreateContainerRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiCreateContainerRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiCreateContainerRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// App requesting for the attributes.
func (r ApiCreateContainerRequest) XCOREOSORIGINTOKEN(xCOREOSORIGINTOKEN string) ApiCreateContainerRequest {
	r.xCOREOSORIGINTOKEN = &xCOREOSORIGINTOKEN
	return r
}

// Create new container
func (r ApiCreateContainerRequest) ContainerCreateRequest(containerCreateRequest ContainerCreateRequest) ApiCreateContainerRequest {
	r.containerCreateRequest = &containerCreateRequest
	return r
}

// Core-os user info
func (r ApiCreateContainerRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiCreateContainerRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiCreateContainerRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.CreateContainerExecute(r)
}

/*
CreateContainer Create a container

**API to create a new container of a particular containerType(given in request):**

  | PARAMETER | DESCRIPTION | TYPE | VALIDATION |
  | ---- | ----- | ---- | --- |
  | `containerType`* | Container type defined using container type configuration APIs. | string | **pattern**: It should match a through z or A through Z, inclusive (range).<br>**minLength**: 3 **maxLength**: 64<br>**Example**: bag |
  | `trackingDetails` | Field to represent tracking ID (such as AWB) for a container which is usually pasted on the container and used for scanning it. There can be multiple tracking IDs for a container, owned by different operators and hence it will be stored as a list. |
  | ㅤ↳`operator`* | Field to specify the owner of the tracking ID. | string | **minLength**: 3 **maxLength**: 64<br>**Example**: Delhivery |
  | ㅤ↳`trackingId`* | | string | **minLength**: 1 **maxLength**: 128<br>**Example**: 132121232423232 |
  | ㅤ↳`isPrimary` | It defines whether it is a primary tracking ID or not. If not defined we assume first tracking ID as primary tracking ID. | boolean | **Default**: false |
  | `attributes` | A map to provide values for the attributes defined in Container-type configuration APIs. |
  | `items` | List of items can be added into a container only if the container-type is a leaf. |
  | ㅤ↳`name`* | Name of the item. | string | **minLength**: 3 **maxLength**: 128<br>**Example**: pant/shirt |
  | ㅤ↳`code` | Code of the item. | string |  **minLength**: 3 **maxLength**: 128 |
  | ㅤ↳`cost`* | Cost of the item. |
  | ㅤㅤ↳`unit` | Represents unit price of the item. |
  | ㅤㅤㅤ↳`amount` | The value of the amount; accurate to three decimal places. | number |
  | ㅤㅤㅤ↳`currency` | Currency of the price of the item. | string |
  | ㅤㅤ↳`total`* | Represents total price of the item. |
  | ㅤㅤㅤ↳`amount` | The value of the amount; accurate to three decimal places. | number |
  | ㅤㅤㅤ↳`currency` | Currency of the price of the item. | string |
  | ㅤ↳`quantity` |
  | ㅤㅤ↳`value` | A number quantifying measurement. | integer |
  | ㅤㅤ↳`unit` | Unit for measurement. | string | **Enum**: [cm, m, l, ml, nos, g, kg, mm] |
  | `isHazmat` | Represents whether this container can contain hazardous materials or not. | boolean | **Default**: false |
  | `isContainerizable` | Defines whether container can be put into other containers or not. | boolean | **Default**: true |
  | `callback` | Represents callback URL, which can be to notify status(success/failed) of API. | object | {url: "string", meta: "string"} |
  *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **202 - Accepted** |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **503 - Server Error** | Something went wrong.. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerId Type of container
 @return ApiCreateContainerRequest
*/
func (a *ContainerApiService) CreateContainer(ctx context.Context, containerId string) ApiCreateContainerRequest {
	return ApiCreateContainerRequest{
		ApiService: a,
		ctx: ctx,
		containerId: containerId,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerApiService) CreateContainerExecute(r ApiCreateContainerRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerApiService.CreateContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(parameterToString(r.containerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSORIGINTOKEN == nil {
		return localVarReturnValue, nil, reportError("xCOREOSORIGINTOKEN is required and must be specified")
	}
	if r.containerCreateRequest == nil {
		return localVarReturnValue, nil, reportError("containerCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	localVarHeaderParams["X-COREOS-ORIGIN-TOKEN"] = parameterToString(*r.xCOREOSORIGINTOKEN, "")
	// body params
	localVarPostBody = r.containerCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerByIdRequest struct {
	ctx context.Context
	ApiService *ContainerApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerId string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetContainerByIdRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetContainerByIdRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetContainerByIdRequest) XCOREOSTID(xCOREOSTID string) ApiGetContainerByIdRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetContainerByIdRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetContainerByIdRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetContainerByIdRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetContainerByIdRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetContainerByIdRequest) Execute() (*ContainerResponse, *http.Response, error) {
	return r.ApiService.GetContainerByIdExecute(r)
}

/*
GetContainerById Fetch details of container

**API to get information (base & core attribute values) of a container specified by containerId.**
 | HEADER/PATH/QUERY | DESCRIPTION | TYPE |
 | ---- | ---- | ----- |
 | `X-COREOS-REQUEST-ID`*(header) | Unique request ID. | string |
 | `X-COREOS-TID`*(header) | Tenant ID. | string |
 | `X-COREOS-ACCESS`*(header) | Core-OS access token. | string |
 |
 | `containerId`*(path) | Unique ID of Container. | string |
 | `containerType`*(query) | Type of container. | string |
 *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **200 - OK** | Everything worked as expected. |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerId Unique id of Container
 @return ApiGetContainerByIdRequest
*/
func (a *ContainerApiService) GetContainerById(ctx context.Context, containerId string) ApiGetContainerByIdRequest {
	return ApiGetContainerByIdRequest{
		ApiService: a,
		ctx: ctx,
		containerId: containerId,
	}
}

// Execute executes the request
//  @return ContainerResponse
func (a *ContainerApiService) GetContainerByIdExecute(r ApiGetContainerByIdRequest) (*ContainerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerApiService.GetContainerById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(parameterToString(r.containerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainerByTrackingIdRequest struct {
	ctx context.Context
	ApiService *ContainerApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	trackingId string
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiGetContainerByTrackingIdRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetContainerByTrackingIdRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetContainerByTrackingIdRequest) XCOREOSTID(xCOREOSTID string) ApiGetContainerByTrackingIdRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetContainerByTrackingIdRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetContainerByTrackingIdRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetContainerByTrackingIdRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetContainerByTrackingIdRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiGetContainerByTrackingIdRequest) Execute() (*ContainerTrackingResponse, *http.Response, error) {
	return r.ApiService.GetContainerByTrackingIdExecute(r)
}

/*
GetContainerByTrackingId Fetch details of container by trackingId

**Container is a physical entity which must have a trackingId(scannableId, photoId, RFId) associated with it.**<br><br>**This api will fetch all the details of container specified by trackingId(scannableId, photoId, RFId).**
 | HEADER/PATH/QUERY | DESCRIPTION | TYPE |
 | ---- | ---- | ----- |
 | `X-COREOS-REQUEST-ID`*(header) | Unique request ID. | string |
 | `X-COREOS-TID`*(header) | Tenant ID. | string |
 | `X-COREOS-ACCESS`*(header) | Core-OS access token. | string |
 | `trackingId`*(path) | Tracking ID of container. | string|
 *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **200 - OK** | Everything worked as expected. |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong.. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param trackingId Tracking id of container
 @return ApiGetContainerByTrackingIdRequest
*/
func (a *ContainerApiService) GetContainerByTrackingId(ctx context.Context, trackingId string) ApiGetContainerByTrackingIdRequest {
	return ApiGetContainerByTrackingIdRequest{
		ApiService: a,
		ctx: ctx,
		trackingId: trackingId,
	}
}

// Execute executes the request
//  @return ContainerTrackingResponse
func (a *ContainerApiService) GetContainerByTrackingIdExecute(r ApiGetContainerByTrackingIdRequest) (*ContainerTrackingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainerTrackingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerApiService.GetContainerByTrackingId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracking/{trackingId}"
	localVarPath = strings.Replace(localVarPath, "{"+"trackingId"+"}", url.PathEscape(parameterToString(r.trackingId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContainersRequest struct {
	ctx context.Context
	ApiService *ContainerApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerType string
	xCOREOSUSERINFO *string
	limit *int32
	offset *int32
	select_ *[]string
	query *Query
	sortKey *string
	sortBy *SortBy
}

// Unique request id.
func (r ApiGetContainersRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiGetContainersRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiGetContainersRequest) XCOREOSTID(xCOREOSTID string) ApiGetContainersRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiGetContainersRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiGetContainersRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// Core-os user info
func (r ApiGetContainersRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiGetContainersRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

// Number of items to return.
func (r ApiGetContainersRequest) Limit(limit int32) ApiGetContainersRequest {
	r.limit = &limit
	return r
}

// Number of items to skip from start.
func (r ApiGetContainersRequest) Offset(offset int32) ApiGetContainersRequest {
	r.offset = &offset
	return r
}

// Specifies list of attributes to be included in response (id is always included in response). If not specified, all attributes are included in response.
func (r ApiGetContainersRequest) Select_(select_ []string) ApiGetContainersRequest {
	r.select_ = &select_
	return r
}

// Query criteria. Refer following links for more details:&lt;br/&gt; - [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)&lt;br/&gt; - [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)&lt;br/&gt; - [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)&lt;br/&gt; - [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)&lt;br/&gt; - [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)&lt;br/&gt; - [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)&lt;br/&gt; - [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)&lt;br/&gt; - [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)&lt;br/&gt; - [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)&lt;br/&gt; - [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)&lt;br/&gt; - [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)&lt;br/&gt; - [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
func (r ApiGetContainersRequest) Query(query Query) ApiGetContainersRequest {
	r.query = &query
	return r
}

// key to be used for sorting data
func (r ApiGetContainersRequest) SortKey(sortKey string) ApiGetContainersRequest {
	r.sortKey = &sortKey
	return r
}

// fetching data in ascending(asc) or descending(desc) order.
func (r ApiGetContainersRequest) SortBy(sortBy SortBy) ApiGetContainersRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetContainersRequest) Execute() (*ContainersResponse, *http.Response, error) {
	return r.ApiService.GetContainersExecute(r)
}

/*
GetContainers Fetch container details based on the filters passed.

**API to get information of all containers of container type based on the filters specified.**
 |  HEADER/QUERY PARAMETER   |   DESCRIPTION  |   TYPE    |  VALIDATION   |
  |---  |---  |---  |---  |
  |  `X-COREOS-REQUEST-ID`*(header)   |  Unique request ID.   |  string      |     |
  |  `X-COREOS-TID `*(header)   |   Tenant ID.  |  string      |     |
  | `X-COREOS-ACCESS`*(header) | Core-OS access token. | string  | 
  |
  | `limit`(query) | Number of items to return. | integer  | ㅤ**Default value**: 50 |
  | `offset`(query) | The number of items to skip from start. | integer | ㅤ**Default value**: 0 |
  | `select`(query) | Specifies the list of attributes to be included in the response. If not specified, all attributes are included in the response.| array[string] | ㅤ**Available values**: name, isSystem, <br>ㅤisActive, allowedOwner, ttl |
  | `query`(query) | Query criteria. | object | ㅤRefer following links for more details:<br> <br> ㅤ1. [match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html) <br> ㅤ2. [multi_match](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)<br> ㅤ3. [term](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)<br> ㅤ4. [terms](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)<br> ㅤ5. [range](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)<br> ㅤ6. [regexp](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)<br> ㅤ7. [exists](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)<br> ㅤ8. [fuzzy](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)<br> ㅤ9. [prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)<br>  10. [wildcard](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)<br>  11. [match_phrase](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)<br>  12. [match_phrase_prefix](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html) |
  | `sortKey`(query) | Key to be used for sorting data. | string |  **Default value**: createdAt |
  | `sortBy`(query) | Fetching data in ascending (asc) or descending (desc) order. | string | **Available values**: desc, asc<br>**Default value**: desc |
  | `containerType`*(query) | Type of container. | string |
  *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **200 - OK** | Everything worked as expected. |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **404 - Not Found** | The requested resource doesn't exist. |
   | **503 - Server Error** | Something went wrong. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerType Type of container
 @return ApiGetContainersRequest
*/
func (a *ContainerApiService) GetContainers(ctx context.Context, containerType string) ApiGetContainersRequest {
	return ApiGetContainersRequest{
		ApiService: a,
		ctx: ctx,
		containerType: containerType,
	}
}

// Execute executes the request
//  @return ContainersResponse
func (a *ContainerApiService) GetContainersExecute(r ApiGetContainersRequest) (*ContainersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContainersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerApiService.GetContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerType}/filter"
	localVarPath = strings.Replace(localVarPath, "{"+"containerType"+"}", url.PathEscape(parameterToString(r.containerType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("select", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("select", parameterToString(t, "multi"))
		}
	}
	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.sortKey != nil {
		localVarQueryParams.Add("sortKey", parameterToString(*r.sortKey, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateContainerByIdRequest struct {
	ctx context.Context
	ApiService *ContainerApiService
	xCOREOSREQUESTID *string
	xCOREOSTID *string
	xCOREOSACCESS *string
	containerId string
	xCOREOSORIGINTOKEN *string
	containerUpdateRequest *ContainerUpdateRequest
	xCOREOSUSERINFO *string
}

// Unique request id.
func (r ApiUpdateContainerByIdRequest) XCOREOSREQUESTID(xCOREOSREQUESTID string) ApiUpdateContainerByIdRequest {
	r.xCOREOSREQUESTID = &xCOREOSREQUESTID
	return r
}

// Tenant id
func (r ApiUpdateContainerByIdRequest) XCOREOSTID(xCOREOSTID string) ApiUpdateContainerByIdRequest {
	r.xCOREOSTID = &xCOREOSTID
	return r
}

// Core-os access token
func (r ApiUpdateContainerByIdRequest) XCOREOSACCESS(xCOREOSACCESS string) ApiUpdateContainerByIdRequest {
	r.xCOREOSACCESS = &xCOREOSACCESS
	return r
}

// App requesting for the attributes.
func (r ApiUpdateContainerByIdRequest) XCOREOSORIGINTOKEN(xCOREOSORIGINTOKEN string) ApiUpdateContainerByIdRequest {
	r.xCOREOSORIGINTOKEN = &xCOREOSORIGINTOKEN
	return r
}

// Update container
func (r ApiUpdateContainerByIdRequest) ContainerUpdateRequest(containerUpdateRequest ContainerUpdateRequest) ApiUpdateContainerByIdRequest {
	r.containerUpdateRequest = &containerUpdateRequest
	return r
}

// Core-os user info
func (r ApiUpdateContainerByIdRequest) XCOREOSUSERINFO(xCOREOSUSERINFO string) ApiUpdateContainerByIdRequest {
	r.xCOREOSUSERINFO = &xCOREOSUSERINFO
	return r
}

func (r ApiUpdateContainerByIdRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.UpdateContainerByIdExecute(r)
}

/*
UpdateContainerById Update attribute of Container

**API to update the attributes of container.**


 | PARAMETER | DESCRIPTION | TYPE | VALIDATION |
 | ---- | ---- | --- | --- |
 | `trackingDetails` | Field to represent tracking ID (such as AWB) for a container which is usually pasted on the container and used for scanning it. There can be multiple tracking IDs for a container, owned by different operators and hence it will be stored as a list. |
 | ㅤ↳`operator` | Field to specify the owner of the tracking ID. | string | **minLength**: 3 **maxLength**: 64<br>**Example**: Delhivery |
 | ㅤ↳`trackingId`* | | string | **minLength**: 1 **maxLength**: 128<br>**Example**: 132121232423232 |
  | ㅤ↳`isPrimary` | It defines whether it is a primary tracking id or not. If not defined we assume first tracking id as primary tracking id. | boolean | **Default**: false |
  | `attributes` | A map to provide values for the attributes defined in Container-type configuration APIs. |
  | `items` | List of items can be added into a container only if the container-type is a leaf. |
  | ㅤ↳`name`* | Name of the item. | string | **minLength**: 3 **maxLength**: 128<br>**Example**: pant/shirt |
  | ㅤ↳`code` | Code of the item. | string |  **minLength**: 3 **maxLength**: 128 |
  | ㅤ↳`cost`* | Cost of the item. |
  | ㅤㅤ↳`unit` | Represents unit price of the item. |
  | ㅤㅤㅤ↳`amount` | The value of the amount; accurate to three decimal places. | number |
  | ㅤㅤㅤ↳`currency` | Currency of the price of the item. | string |
  | ㅤㅤ↳`total`* | Represents total price of the item. |
  | ㅤㅤㅤ↳`amount` | The value of the amount; accurate to three decimal places. | number |
  | ㅤㅤㅤ↳`currency` | Currency of the price of the item. | string |
  | ㅤ↳`quantity` |
  | ㅤㅤ↳`value` | A number quantifying measurement. | integer |
  | ㅤㅤ↳`unit` | Unit for measurement. | string | **Enum**: [cm, m, l, ml, nos, g, kg, mm] |
  | `callback` | Represents callback URL, which can be to notify status(success/failed) of API. | object | {url: "string", meta: "string"} |
  *This is required.
   <br><br>
   **HTTP Status Code Summary**
   | Code | Description |
   | ---- | ---------- |
   | **202 - Accepted** |
   | **400 - Bad Request** | The request was unacceptable, often due to missing a required parameter. |
   | **401 - Unauthorized** | No valid API key provided. |
   | **503 - Server Error** | Something went wrong.. (These are rare.) |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param containerId Unique id of Container
 @return ApiUpdateContainerByIdRequest
*/
func (a *ContainerApiService) UpdateContainerById(ctx context.Context, containerId string) ApiUpdateContainerByIdRequest {
	return ApiUpdateContainerByIdRequest{
		ApiService: a,
		ctx: ctx,
		containerId: containerId,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *ContainerApiService) UpdateContainerByIdExecute(r ApiUpdateContainerByIdRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContainerApiService.UpdateContainerById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{containerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(parameterToString(r.containerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xCOREOSREQUESTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSREQUESTID is required and must be specified")
	}
	if r.xCOREOSTID == nil {
		return localVarReturnValue, nil, reportError("xCOREOSTID is required and must be specified")
	}
	if r.xCOREOSACCESS == nil {
		return localVarReturnValue, nil, reportError("xCOREOSACCESS is required and must be specified")
	}
	if r.xCOREOSORIGINTOKEN == nil {
		return localVarReturnValue, nil, reportError("xCOREOSORIGINTOKEN is required and must be specified")
	}
	if r.containerUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("containerUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-COREOS-REQUEST-ID"] = parameterToString(*r.xCOREOSREQUESTID, "")
	localVarHeaderParams["X-COREOS-TID"] = parameterToString(*r.xCOREOSTID, "")
	localVarHeaderParams["X-COREOS-ACCESS"] = parameterToString(*r.xCOREOSACCESS, "")
	if r.xCOREOSUSERINFO != nil {
		localVarHeaderParams["X-COREOS-USERINFO"] = parameterToString(*r.xCOREOSUSERINFO, "")
	}
	localVarHeaderParams["X-COREOS-ORIGIN-TOKEN"] = parameterToString(*r.xCOREOSORIGINTOKEN, "")
	// body params
	localVarPostBody = r.containerUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
