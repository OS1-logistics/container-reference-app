// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package api

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/gin-gonic/gin"
)

// Defines values for ChildSchema.
const (
	CONTAINERIZE   ChildSchema = "CONTAINERIZE"
	DECONTAINERIZE ChildSchema = "DECONTAINERIZE"
)

// Defines values for DataTypeSchema.
const (
	Array   DataTypeSchema = "array"
	Boolean DataTypeSchema = "boolean"
	Number  DataTypeSchema = "number"
	Object  DataTypeSchema = "object"
	String  DataTypeSchema = "string"
)

// Defines values for Method.
const (
	GET  Method = "GET"
	POST Method = "POST"
	PUT  Method = "PUT"
)

// Defines values for Type.
const (
	TypeBag      Type = "bag"
	TypeShipment Type = "shipment"
)

// Defines values for UpdateAttributeParamsType.
const (
	UpdateAttributeParamsTypeBag      UpdateAttributeParamsType = "bag"
	UpdateAttributeParamsTypeShipment UpdateAttributeParamsType = "shipment"
)

// Defines values for UpdateShipmentAttributeParamsType.
const (
	Bag      UpdateShipmentAttributeParamsType = "bag"
	Shipment UpdateShipmentAttributeParamsType = "shipment"
)

// ActionBy defines model for ActionBy.
type ActionBy struct {
	Id   string  `json:"id"`
	Name *string `json:"name,omitempty"`
}

// ActionInfo defines model for ActionInfo.
type ActionInfo struct {
	CreatedAt int64    `json:"createdAt"`
	CreatedBy ActionBy `json:"createdBy"`
	UpdatedAt int64    `json:"updatedAt"`
	UpdatedBy ActionBy `json:"updatedBy"`
}

// AttributeNameSchema Name of the attribute
type AttributeNameSchema = string

// AttributeUpdateSchema defines model for AttributeUpdate.
type AttributeUpdateSchema struct {
	// DataType Data Type of value of the attribute
	DataTypeSchema DataTypeSchema                `json:"dataType"`
	DefaultValue   *AttributeUpdate_DefaultValue `json:"defaultValue,omitempty"`

	// Description Description of the attribute
	DescriptionSchema *DescriptionSchema `json:"description,omitempty"`
	Indexed           *bool              `json:"indexed,omitempty"`

	// Name Name of the attribute
	AttributeNameSchema AttributeNameSchema `json:"name"`

	// Validation Validation rules for a string or number value
	ValidationSchema *ValidationSchema `json:"validation,omitempty"`
}

// AttributeUpdateDefaultValue0 defines model for .
type AttributeUpdateDefaultValue0 = bool

// AttributeUpdateDefaultValue1 defines model for .
type AttributeUpdateDefaultValue1 = float32

// AttributeUpdateDefaultValue2 defines model for .
type AttributeUpdateDefaultValue2 = string

// AttributeUpdate_DefaultValue defines model for AttributeUpdate.DefaultValue.
type AttributeUpdate_DefaultValue struct {
	union json.RawMessage
}

// AttributeUpdateRequestSchema Update an attribute
type AttributeUpdateRequestSchema struct {
	Attributes *[]AttributeUpdateSchema `json:"attributes,omitempty"`
}

// AttributesResponseSchema defines model for AttributesResponse.
type AttributesResponseSchema struct {
	Data *struct {
		Attributes *[]map[string]interface{} `json:"attributes,omitempty"`
		Meta       *struct {
			TotalElements *int64 `json:"totalElements,omitempty"`
		} `json:"meta,omitempty"`
	} `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema *ErrorSchema `json:"error,omitempty"`
}

// BagBaseSchema defines model for BagBase.
type BagBaseSchema = map[string]interface{}

// BagCreateRequestSchema defines model for BagCreateRequest.
type BagCreateRequestSchema struct {
	Destination    *string `json:"destination,omitempty"`
	OriginLocation *string `json:"originLocation,omitempty"`
}

// BagReadOnlySchema defines model for BagReadOnly.
type BagReadOnlySchema struct {
	Destination    *string `json:"destination,omitempty"`
	OriginLocation *string `json:"originLocation,omitempty"`
}

// BagSystemSchema defines model for BagSystem.
type BagSystemSchema struct {
	// CreatedAt Timestamp of when the bag was created. Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
	CreatedAt *int `json:"createdAt,omitempty"`

	// CurrentLocation current location of the shipment
	CurrentLocation *string `json:"currentLocation,omitempty"`
	Id              *string `json:"id,omitempty"`
	Mot             *string `json:"mot,omitempty"`
	MoveTogether    *bool   `json:"moveTogether,omitempty"`
	Ntc             *string `json:"ntc,omitempty"`
	ProductType     *string `json:"productType,omitempty"`
	ShipmentFlow    *string `json:"shipmentFlow,omitempty"`
	Sot             *string `json:"sot,omitempty"`

	// Status Status of the bag
	Status *string `json:"status,omitempty"`

	// UpdatedAt Timestamp of when the bag was last updated. Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
	UpdatedAt *int `json:"updatedAt,omitempty"`
}

// BagUpdateRequestSchema defines model for BagUpdateRequest.
type BagUpdateRequestSchema = BagBaseSchema

// BaggingConfigUploadDataSchema defines model for BaggingConfigUploadData.
type BaggingConfigUploadDataSchema struct {
	DownloadURL *string `json:"downloadURL,omitempty"`

	// Failure The number of rows failed insert
	Failure  *float32 `json:"failure,omitempty"`
	FileName *string  `json:"fileName,omitempty"`

	// Success The number of rows successfully inserted
	Success *float32 `json:"success,omitempty"`

	// Total The number of rows present in uploaded file
	Total      *float32 `json:"total,omitempty"`
	UploadedBy *string  `json:"uploadedBy,omitempty"`
	UploadedOn *string  `json:"uploadedOn,omitempty"`
}

// BaggingConfigUploadRequest defines model for BaggingConfigUploadRequest.
type BaggingConfigUploadRequest struct {
	// Baggingconfig CSV file with bagging config details in the given format
	Baggingconfig *openapi_types.File `json:"baggingconfig,omitempty"`
}

// BaggingConfigUploadResponseSchema defines model for BaggingConfigUploadResponse.
type BaggingConfigUploadResponseSchema struct {
	BaggingConfigUploadDataSchema *BaggingConfigUploadDataSchema `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// ChildSchema Specifies this request perform containerization or decontainerization.
type ChildSchema string

// ChildContainerResponseSchema defines model for ChildContainerResponse.
type ChildContainerResponseSchema struct {
	Data *struct {
		// Id container id
		Id *string `json:"id,omitempty"`

		// Operation Specifies this request perform containerization or decontainerization.
		ChildSchema *ChildSchema `json:"operation,omitempty"`
	} `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// ContainerChangeState defines model for ContainerChangeState.
type ContainerChangeState struct {
	// Callback Represents callback url, which can be called to get any info about state change of a container and notify status(success/failed) of api.
	Callback *string `json:"callback,omitempty"`
	Id       *string `json:"id,omitempty"`

	// State Represents state of the container.The value will of the format <state>:<substate>
	State *StateRepresentation `json:"state,omitempty"`
}

// ContainerStateSchema defines model for ContainerState.
type ContainerStateSchema struct {
	EventSchema *EventSchema `json:"event,omitempty"`
	Id          *string      `json:"id,omitempty"`

	// State Represents state of the container.The value will of the format <state>:<substate>
	State *StateRepresentation `json:"state,omitempty"`

	// StateChange Describes if the state is changed.
	StateChange *bool `json:"stateChange,omitempty"`

	// TerminalTtl Describes terminal ttl if the state is a terminal state
	TerminalTtl *int `json:"terminalTtl,omitempty"`
}

// ContainerStateResponseSchema defines model for ContainerStateResponse.
type ContainerStateResponseSchema struct {
	ContainerStateSchema *ContainerStateSchema `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// ContainerStateUpdateRequestSchema defines model for ContainerStateUpdateRequest.
type ContainerStateUpdateRequestSchema = EventSchema

// ContainerStateUpdateResponseSchema defines model for ContainerStateUpdateResponse.
type ContainerStateUpdateResponseSchema struct {
	Data *ContainerChangeState `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// ContainerTypeBasicPropertiesSchema defines model for ContainerTypeBasicProperties.
type ContainerTypeBasicPropertiesSchema struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// ContainerizationBaseSchema defines model for ContainerizationBase.
type ContainerizationBaseSchema struct {
	// CallBackUrl Callback URL for async response
	CallBackUrl *string `json:"callBackUrl,omitempty"`

	// ParentId Id of the parent container
	ParentId string `json:"parentId"`
}

// ContainerizationRequestSchema defines model for ContainerizationRequest.
type ContainerizationRequestSchema = ContainerizationBaseSchema

// CreatedResponseSchema defines model for CreatedResponse.
type CreatedResponseSchema struct {
	DataSchema *DataSchema `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// DataSchema defines model for Data.
type DataSchema struct {
	Id *string `json:"id,omitempty"`
}

// DataTypeSchema Data Type of value of the attribute
type DataTypeSchema string

// DefaultResponseSchema defines model for DefaultResponse.
type DefaultResponseSchema struct {
	Data *map[string]interface{} `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// DescriptionSchema Description of the attribute
type DescriptionSchema = string

// ErrorSchema Error Information
type ErrorSchema struct {
	// AdditionalInfo Additional information related to the error
	AdditionalInfo *map[string]interface{} `json:"additionalInfo,omitempty"`

	// Code Error code
	Code string `json:"code"`

	// Description Error description
	Description string `json:"description"`
}

// EventSchema defines model for Event.
type EventSchema struct {
	// Data Represents event data values, if any, for this event
	Data map[string]interface{} `json:"data"`

	// EventCode Represents eventCode for state transition
	EventCode string `json:"eventCode"`

	// ReasonCode Represents reasonCode for state transition
	ReasonCode string `json:"reasonCode"`
}

// Method HTTP method requested on the API endpoint
type Method string

// RangeSchema Minimum & maximum values if data type is number. Minimum and maximum length if data type is string
type RangeSchema struct {
	Max *float32 `json:"max,omitempty"`
	Min *float32 `json:"min,omitempty"`
}

// RequestSchema defines model for Request.
type RequestSchema struct {
	Body *map[string]interface{} `json:"body,omitempty"`

	// Method HTTP method requested on the API endpoint
	Method      *Method `json:"method,omitempty"`
	QueryString *string `json:"queryString,omitempty"`
	Uri         *string `json:"uri,omitempty"`
}

// ShipmentBaseSchema defines model for ShipmentBase.
type ShipmentBaseSchema struct {
	ShipmentReadOnlySchema *ShipmentReadOnlySchema `json:"attributes,omitempty"`

	// IsContainerizable Defines whether container can be put into other containers or not.
	IsContainerizable *bool `json:"isContainerizable,omitempty"`

	// IsHazmat Represents whether this container can contain hazardous materials or not
	IsHazmat *bool `json:"isHazmat,omitempty"`
}

// ShipmentCoreSchema defines model for ShipmentCore.
type ShipmentCoreSchema struct {
	// TrackingDetails Status of the shipment
	TrackingDetails *[]TrackingDetailSchema `json:"trackingDetails,omitempty"`
}

// ShipmentCreateRequestSchema defines model for ShipmentCreateRequest.
type ShipmentCreateRequestSchema struct {
	ShipmentReadOnlySchema *ShipmentReadOnlySchema `json:"attributes,omitempty"`

	// IsContainerizable Defines whether container can be put into other containers or not.
	IsContainerizable *bool `json:"isContainerizable,omitempty"`

	// IsHazmat Represents whether this container can contain hazardous materials or not
	IsHazmat *bool `json:"isHazmat,omitempty"`

	// TrackingDetails Status of the shipment
	TrackingDetails *[]TrackingDetailSchema `json:"trackingDetails,omitempty"`
}

// ShipmentReadOnlySchema defines model for ShipmentReadOnly.
type ShipmentReadOnlySchema struct {
	Amount struct {
		// CurrencyCode Country code
		CurrencyCode *string `json:"currencyCode,omitempty"`

		// MinorUnit Minor unit of currency
		MinorUnit *float32 `json:"minorUnit,omitempty"`
		Value     *float32 `json:"value,omitempty"`
	} `json:"amount"`
	ClientContainerId string  `json:"clientContainerId"`
	ClientId          *string `json:"clientId,omitempty"`
	Description       string  `json:"description"`

	// Dimensions Size of the shipment
	Dimensions *struct {
		Breadth *float32 `json:"breadth,omitempty"`
		Height  *float32 `json:"height,omitempty"`
		Length  *float32 `json:"length,omitempty"`

		// Weight Dead weight of the shipment
		Weight *float32 `json:"weight,omitempty"`
	} `json:"dimensions,omitempty"`

	// LsId Ls id of the container
	LsId            string  `json:"lsId"`
	MaxAttemptCount float32 `json:"maxAttemptCount"`
	ScanLocation    *string `json:"scanLocation,omitempty"`
}

// ShipmentUpdateRequestSchema defines model for ShipmentUpdateRequest.
type ShipmentUpdateRequestSchema struct {
	Attributes *struct {
		ShipmentReadOnlySchema *ShipmentReadOnlySchema `json:"attributes,omitempty"`

		// IsContainerizable Defines whether container can be put into other containers or not.
		IsContainerizable *bool `json:"isContainerizable,omitempty"`

		// IsHazmat Represents whether this container can contain hazardous materials or not
		IsHazmat *bool `json:"isHazmat,omitempty"`

		// TrackingDetails Status of the shipment
		TrackingDetails *[]TrackingDetailSchema `json:"trackingDetails,omitempty"`
	} `json:"attributes,omitempty"`
	Event *EventSchema `json:"event,omitempty"`
}

// StateMachineConfigSchema Container type state-machine configuration
type StateMachineConfigSchema struct {
	Events []map[string]interface{} `json:"events"`

	// TerminalTTL Represents time to live of an instance in transactional database after it has reached a terminal state.
	TerminalTTL string `json:"terminalTTL"`
}

// StateMachineConfigResponseSchema defines model for StateMachineConfigResponse.
type StateMachineConfigResponseSchema struct {
	Data *StateMachineConfigResponseData `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// StateMachineConfigResponseData defines model for StateMachineConfigResponseData.
type StateMachineConfigResponseData struct {
	CreatedAt int64                    `json:"createdAt"`
	CreatedBy ActionBy                 `json:"createdBy"`
	Events    []map[string]interface{} `json:"events"`
	Id        *string                  `json:"id,omitempty"`
	Name      *string                  `json:"name,omitempty"`

	// TerminalTTL Represents time to live of an instance in transactional database after it has reached a terminal state.
	TerminalTTL string   `json:"terminalTTL"`
	UpdatedAt   int64    `json:"updatedAt"`
	UpdatedBy   ActionBy `json:"updatedBy"`
}

// StateMachineUpdateRequestSchema Container type state-machine configuration
type StateMachineUpdateRequestSchema = StateMachineConfigSchema

// StateRepresentation Represents state of the container.The value will of the format <state>:<substate>
type StateRepresentation = string

// SuccessResponseSchema Error Information
type SuccessResponseSchema = ErrorSchema

// ValidationSchema Validation rules for a string or number value
type ValidationSchema struct {
	// Range Minimum & maximum values if data type is number. Minimum and maximum length if data type is string
	RangeSchema *RangeSchema `json:"range,omitempty"`

	// Regex Regex pattern that the string type data should match
	Regex *string `json:"regex,omitempty"`

	// Required Specifies whether the value is required or optional
	Required *bool `json:"required,omitempty"`

	// ValueOneOf Enum of accepted values
	ValueOneOf *[]string `json:"valueOneOf,omitempty"`
}

// TrackingDetailSchema defines model for trackingDetail.
type TrackingDetailSchema struct {
	IsPrimary  *bool   `json:"isPrimary,omitempty"`
	Operator   *string `json:"operator,omitempty"`
	TrackingId *string `json:"trackingId,omitempty"`
}

// PageOffset defines model for PageOffset.
type PageOffset = int

// PageSize defines model for PageSize.
type PageSize = int

// RequestId defines model for RequestId.
type RequestId = string

// Status defines model for Status.
type Status = string

// TenantId defines model for TenantId.
type TenantId = string

// Type defines model for Type.
type Type string

// AttributesResponse defines model for AttributesResponse.
type AttributesResponse = AttributesResponseSchema

// BaggingConfigUploadResponse defines model for BaggingConfigUploadResponse.
type BaggingConfigUploadResponse = BaggingConfigUploadResponseSchema

// ChildContainerResponse defines model for ChildContainerResponse.
type ChildContainerResponse = ChildContainerResponseSchema

// ContainerStateResponse defines model for ContainerStateResponse.
type ContainerStateResponse = ContainerStateResponseSchema

// ContainerStateUpdateResponse defines model for ContainerStateUpdateResponse.
type ContainerStateUpdateResponse = ContainerStateUpdateResponseSchema

// CreatedResponse defines model for CreatedResponse.
type CreatedResponse = CreatedResponseSchema

// DefaultResponse defines model for DefaultResponse.
type DefaultResponse = DefaultResponseSchema

// GetBagResponse defines model for GetBagResponse.
type GetBagResponse struct {
	Data *struct {
		// CreatedAt Timestamp of when the bag was created. Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
		CreatedAt *int `json:"createdAt,omitempty"`

		// CurrentLocation current location of the shipment
		CurrentLocation *string `json:"currentLocation,omitempty"`
		Destination     *string `json:"destination,omitempty"`
		Id              *string `json:"id,omitempty"`
		Mot             *string `json:"mot,omitempty"`
		MoveTogether    *bool   `json:"moveTogether,omitempty"`
		Ntc             *string `json:"ntc,omitempty"`
		OriginLocation  *string `json:"originLocation,omitempty"`
		ProductType     *string `json:"productType,omitempty"`
		ShipmentFlow    *string `json:"shipmentFlow,omitempty"`
		Sot             *string `json:"sot,omitempty"`

		// Status Status of the bag
		Status *string `json:"status,omitempty"`

		// UpdatedAt Timestamp of when the bag was last updated. Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
		UpdatedAt *int `json:"updatedAt,omitempty"`
	} `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// GetBagsResponse defines model for GetBagsResponse.
type GetBagsResponse struct {
	Data *struct {
		Bags *[]struct {
			// CreatedAt Timestamp of when the bag was created. Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
			CreatedAt *int `json:"createdAt,omitempty"`

			// CurrentLocation current location of the shipment
			CurrentLocation *string `json:"currentLocation,omitempty"`
			Destination     *string `json:"destination,omitempty"`
			Id              *string `json:"id,omitempty"`
			Mot             *string `json:"mot,omitempty"`
			MoveTogether    *bool   `json:"moveTogether,omitempty"`
			Ntc             *string `json:"ntc,omitempty"`
			OriginLocation  *string `json:"originLocation,omitempty"`
			ProductType     *string `json:"productType,omitempty"`
			ShipmentFlow    *string `json:"shipmentFlow,omitempty"`
			Sot             *string `json:"sot,omitempty"`

			// Status Status of the bag
			Status *string `json:"status,omitempty"`

			// UpdatedAt Timestamp of when the bag was last updated. Represents a date time as number of seconds elapsed since 00:00Hrs of 1st January 1970 UTC.
			UpdatedAt *int `json:"updatedAt,omitempty"`
		} `json:"bags,omitempty"`
		Meta *struct {
			TotalElements *float32 `json:"totalElements,omitempty"`
		} `json:"meta,omitempty"`
	} `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// GetShipmentResponse defines model for GetShipmentResponse.
type GetShipmentResponse struct {
	Data *struct {
		ShipmentReadOnlySchema *ShipmentReadOnlySchema `json:"attributes,omitempty"`

		// IsContainerizable Defines whether container can be put into other containers or not.
		IsContainerizable *bool `json:"isContainerizable,omitempty"`

		// IsHazmat Represents whether this container can contain hazardous materials or not
		IsHazmat *bool `json:"isHazmat,omitempty"`

		// TrackingDetails Status of the shipment
		TrackingDetails *[]TrackingDetailSchema `json:"trackingDetails,omitempty"`
	} `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// GetShipmentsResponse defines model for GetShipmentsResponse.
type GetShipmentsResponse struct {
	Data *struct {
		Meta *struct {
			TotalElements *float32 `json:"totalElements,omitempty"`
		} `json:"meta,omitempty"`
		Shipments *[]struct {
			ShipmentReadOnlySchema *ShipmentReadOnlySchema `json:"attributes,omitempty"`

			// IsContainerizable Defines whether container can be put into other containers or not.
			IsContainerizable *bool `json:"isContainerizable,omitempty"`

			// IsHazmat Represents whether this container can contain hazardous materials or not
			IsHazmat *bool `json:"isHazmat,omitempty"`

			// TrackingDetails Status of the shipment
			TrackingDetails *[]TrackingDetailSchema `json:"trackingDetails,omitempty"`
		} `json:"shipments,omitempty"`
	} `json:"data,omitempty"`

	// Error Error Information
	ErrorSchema   *ErrorSchema   `json:"error,omitempty"`
	RequestSchema *RequestSchema `json:"request,omitempty"`
}

// StateMachineConfigResponse defines model for StateMachineConfigResponse.
type StateMachineConfigResponse = StateMachineConfigResponseSchema

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse = SuccessResponseSchema

// AttributeUpdateRequest Update an attribute
type AttributeUpdateRequest = AttributeUpdateRequestSchema

// BagCreateRequest defines model for BagCreateRequest.
type BagCreateRequest = BagCreateRequestSchema

// BagUpdateRequest defines model for BagUpdateRequest.
type BagUpdateRequest = BagUpdateRequestSchema

// ContainerStateUpdateRequest Event for container state transition.
type ContainerStateUpdateRequest = ContainerStateUpdateRequestSchema

// ContainerizationRequest defines model for ContainerizationRequest.
type ContainerizationRequest = ContainerizationRequestSchema

// ShipmentCreateRequest defines model for ShipmentCreateRequest.
type ShipmentCreateRequest = ShipmentCreateRequestSchema

// ShipmentUpdateRequest defines model for ShipmentUpdateRequest.
type ShipmentUpdateRequest = ShipmentUpdateRequestSchema

// StateMachineUpdateRequest Update state machine config
type StateMachineUpdateRequest = StateMachineUpdateRequestSchema

// GetBagsParams defines parameters for GetBags.
type GetBagsParams struct {
	// Status Status of the bag to filter by.
	Status *Status `form:"status,omitempty" json:"status,omitempty"`

	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// CreateBagParams defines parameters for CreateBag.
type CreateBagParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// GetAttributesParams defines parameters for GetAttributes.
type GetAttributesParams struct {
	// Limit Number of items to return.
	Limit *PageSize `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip from start.
	Offset *PageOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// UpdateAttributeParams defines parameters for UpdateAttribute.
type UpdateAttributeParams struct {
	// Type Type of the bag to filter by.
	Type *UpdateAttributeParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// UpdateAttributeParamsType defines parameters for UpdateAttribute.
type UpdateAttributeParamsType string

// BagContainerizationParams defines parameters for BagContainerization.
type BagContainerizationParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// GetBagParams defines parameters for GetBag.
type GetBagParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// UpdateBagParams defines parameters for UpdateBag.
type UpdateBagParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// SealBagParams defines parameters for SealBag.
type SealBagParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// GetBagStateParams defines parameters for GetBagState.
type GetBagStateParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// UpdateBagStateParams defines parameters for UpdateBagState.
type UpdateBagStateParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// UnsealBagParams defines parameters for UnsealBag.
type UnsealBagParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// GetShipmentsParams defines parameters for GetShipments.
type GetShipmentsParams struct {
	// Status Status of the bag to filter by.
	Status *Status `form:"status,omitempty" json:"status,omitempty"`

	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// CreateShipmentParams defines parameters for CreateShipment.
type CreateShipmentParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// UpdateShipmentbyClientParams defines parameters for UpdateShipmentbyClient.
type UpdateShipmentbyClientParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// GetShipmentAttributesParams defines parameters for GetShipmentAttributes.
type GetShipmentAttributesParams struct {
	// Limit Number of items to return.
	Limit *PageSize `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip from start.
	Offset *PageOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// UpdateShipmentAttributeParams defines parameters for UpdateShipmentAttribute.
type UpdateShipmentAttributeParams struct {
	// Type Type of the bag to filter by.
	Type *UpdateShipmentAttributeParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// UpdateShipmentAttributeParamsType defines parameters for UpdateShipmentAttribute.
type UpdateShipmentAttributeParamsType string

// ContainerizeParams defines parameters for Containerize.
type ContainerizeParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// ReopenShipmentParams defines parameters for ReopenShipment.
type ReopenShipmentParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// GetShipmentParams defines parameters for GetShipment.
type GetShipmentParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// UpdateShipmentParams defines parameters for UpdateShipment.
type UpdateShipmentParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// GetShipmentStateParams defines parameters for GetShipmentState.
type GetShipmentStateParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// UpdateShipmentStateParams defines parameters for UpdateShipmentState.
type UpdateShipmentStateParams struct {
	// XCOREOSREQUESTID Unique request Id
	XCOREOSREQUESTID RequestId `json:"X-COREOS-REQUEST-ID"`

	// XCOREOSTENANTID Tenant Id
	XCOREOSTENANTID TenantId `json:"X-COREOS-TENANT-ID"`
}

// CreateBagJSONRequestBody defines body for CreateBag for application/json ContentType.
type CreateBagJSONRequestBody = BagCreateRequestSchema

// UpdateAttributeJSONRequestBody defines body for UpdateAttribute for application/json ContentType.
type UpdateAttributeJSONRequestBody = AttributeUpdateRequestSchema

// BagContainerizationMultipartRequestBody defines body for BagContainerization for multipart/form-data ContentType.
type BagContainerizationMultipartRequestBody = BaggingConfigUploadRequest

// PutStateTemplateConfigJSONRequestBody defines body for PutStateTemplateConfig for application/json ContentType.
type PutStateTemplateConfigJSONRequestBody = StateMachineUpdateRequestSchema

// UpdateBagJSONRequestBody defines body for UpdateBag for application/json ContentType.
type UpdateBagJSONRequestBody = BagUpdateRequestSchema

// UpdateBagStateJSONRequestBody defines body for UpdateBagState for application/json ContentType.
type UpdateBagStateJSONRequestBody = ContainerStateUpdateRequestSchema

// CreateShipmentJSONRequestBody defines body for CreateShipment for application/json ContentType.
type CreateShipmentJSONRequestBody = ShipmentCreateRequestSchema

// UpdateShipmentbyClientJSONRequestBody defines body for UpdateShipmentbyClient for application/json ContentType.
type UpdateShipmentbyClientJSONRequestBody = ShipmentUpdateRequestSchema

// UpdateShipmentAttributeJSONRequestBody defines body for UpdateShipmentAttribute for application/json ContentType.
type UpdateShipmentAttributeJSONRequestBody = AttributeUpdateRequestSchema

// PutShipmentStateTemplateConfigJSONRequestBody defines body for PutShipmentStateTemplateConfig for application/json ContentType.
type PutShipmentStateTemplateConfigJSONRequestBody = StateMachineUpdateRequestSchema

// ContainerizeJSONRequestBody defines body for Containerize for application/json ContentType.
type ContainerizeJSONRequestBody = ContainerizationRequestSchema

// UpdateShipmentJSONRequestBody defines body for UpdateShipment for application/json ContentType.
type UpdateShipmentJSONRequestBody = ShipmentUpdateRequestSchema

// UpdateShipmentStateJSONRequestBody defines body for UpdateShipmentState for application/json ContentType.
type UpdateShipmentStateJSONRequestBody = ContainerStateUpdateRequestSchema

// AsAttributeUpdateDefaultValue0 returns the union data inside the AttributeUpdate_DefaultValue as a AttributeUpdateDefaultValue0
func (t AttributeUpdate_DefaultValue) AsAttributeUpdateDefaultValue0() (AttributeUpdateDefaultValue0, error) {
	var body AttributeUpdateDefaultValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAttributeUpdateDefaultValue0 overwrites any union data inside the AttributeUpdate_DefaultValue as the provided AttributeUpdateDefaultValue0
func (t *AttributeUpdate_DefaultValue) FromAttributeUpdateDefaultValue0(v AttributeUpdateDefaultValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAttributeUpdateDefaultValue0 performs a merge with any union data inside the AttributeUpdate_DefaultValue, using the provided AttributeUpdateDefaultValue0
func (t *AttributeUpdate_DefaultValue) MergeAttributeUpdateDefaultValue0(v AttributeUpdateDefaultValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAttributeUpdateDefaultValue1 returns the union data inside the AttributeUpdate_DefaultValue as a AttributeUpdateDefaultValue1
func (t AttributeUpdate_DefaultValue) AsAttributeUpdateDefaultValue1() (AttributeUpdateDefaultValue1, error) {
	var body AttributeUpdateDefaultValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAttributeUpdateDefaultValue1 overwrites any union data inside the AttributeUpdate_DefaultValue as the provided AttributeUpdateDefaultValue1
func (t *AttributeUpdate_DefaultValue) FromAttributeUpdateDefaultValue1(v AttributeUpdateDefaultValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAttributeUpdateDefaultValue1 performs a merge with any union data inside the AttributeUpdate_DefaultValue, using the provided AttributeUpdateDefaultValue1
func (t *AttributeUpdate_DefaultValue) MergeAttributeUpdateDefaultValue1(v AttributeUpdateDefaultValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAttributeUpdateDefaultValue2 returns the union data inside the AttributeUpdate_DefaultValue as a AttributeUpdateDefaultValue2
func (t AttributeUpdate_DefaultValue) AsAttributeUpdateDefaultValue2() (AttributeUpdateDefaultValue2, error) {
	var body AttributeUpdateDefaultValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAttributeUpdateDefaultValue2 overwrites any union data inside the AttributeUpdate_DefaultValue as the provided AttributeUpdateDefaultValue2
func (t *AttributeUpdate_DefaultValue) FromAttributeUpdateDefaultValue2(v AttributeUpdateDefaultValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAttributeUpdateDefaultValue2 performs a merge with any union data inside the AttributeUpdate_DefaultValue, using the provided AttributeUpdateDefaultValue2
func (t *AttributeUpdate_DefaultValue) MergeAttributeUpdateDefaultValue2(v AttributeUpdateDefaultValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AttributeUpdate_DefaultValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AttributeUpdate_DefaultValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get list of current configured Bags
	// (GET /bags)
	GetBags(c *gin.Context, params GetBagsParams)
	// Create a new Bag
	// (POST /bags)
	CreateBag(c *gin.Context, params CreateBagParams)
	// Get list of Attributes
	// (GET /bags/config/attributes)
	GetAttributes(c *gin.Context, params GetAttributesParams)
	// Update details of a Attribute
	// (PUT /bags/config/attributes)
	UpdateAttribute(c *gin.Context, params UpdateAttributeParams)
	// Upload bagging config
	// (POST /bags/config/containerization/upload)
	BagContainerization(c *gin.Context, params BagContainerizationParams)
	// Get the current state machine of a particular resource
	// (GET /bags/config/state-machine)
	GetStateTemplateConfig(c *gin.Context)
	// Update the state machine of a particular resource
	// (PUT /bags/config/state-machine)
	PutStateTemplateConfig(c *gin.Context)
	// Get properties of a configured Bag
	// (GET /bags/{bagId})
	GetBag(c *gin.Context, bagId string, params GetBagParams)
	// Update properties of a configured bag
	// (PUT /bags/{bagId})
	UpdateBag(c *gin.Context, bagId string, params UpdateBagParams)
	// Seal(Close) a bag
	// (PUT /bags/{bagId}/seal/)
	SealBag(c *gin.Context, bagId string, params SealBagParams)
	// Get current state of the bag
	// (GET /bags/{bagId}/state/)
	GetBagState(c *gin.Context, bagId string, params GetBagStateParams)
	// Seal(Close), Open or Discard a bag
	// (PUT /bags/{bagId}/transition/state/)
	UpdateBagState(c *gin.Context, bagId string, params UpdateBagStateParams)
	// Unseal(Open) a bag
	// (PUT /bags/{bagId}/unseal/)
	UnsealBag(c *gin.Context, bagId string, params UnsealBagParams)
	// Get list of current configured Shipments
	// (GET /shipments)
	GetShipments(c *gin.Context, params GetShipmentsParams)
	// Create a new Shipment
	// (POST /shipments)
	CreateShipment(c *gin.Context, params CreateShipmentParams)
	// Update properties of a configured shipment
	// (PUT /shipments/client/{shipmentId})
	UpdateShipmentbyClient(c *gin.Context, shipmentId string, params UpdateShipmentbyClientParams)
	// Get list of Attributes
	// (GET /shipments/config/attributes)
	GetShipmentAttributes(c *gin.Context, params GetShipmentAttributesParams)
	// Update details of a Attribute
	// (PUT /shipments/config/attributes)
	UpdateShipmentAttribute(c *gin.Context, params UpdateShipmentAttributeParams)
	// Get the current State Machine of a particular resource
	// (GET /shipments/config/state-machine)
	GetShipmentStateTemplateConfig(c *gin.Context)
	// Update the State Machine of a particular resource
	// (PUT /shipments/config/state-machine)
	PutShipmentStateTemplateConfig(c *gin.Context)
	// Add or remove a shipment from the bag
	// (PUT /shipments/containerize/{containerId}/)
	Containerize(c *gin.Context, containerId string, params ContainerizeParams)
	// Reopen a Discarded shipemnt
	// (PUT /shipments/reopen/{shipmentId})
	ReopenShipment(c *gin.Context, shipmentId string, params ReopenShipmentParams)
	// Get properties of a configured Shipment
	// (GET /shipments/{shipmentId})
	GetShipment(c *gin.Context, shipmentId string, params GetShipmentParams)
	// Update properties of a configured shipment
	// (PUT /shipments/{shipmentId})
	UpdateShipment(c *gin.Context, shipmentId string, params UpdateShipmentParams)
	// Get current state of the bag
	// (GET /shipments/{shipmentId}/state/)
	GetShipmentState(c *gin.Context, shipmentId string, params GetShipmentStateParams)
	// Seal(Close), Open or Discard a bag
	// (PUT /shipments/{shipmentId}/transition/state/)
	UpdateShipmentState(c *gin.Context, shipmentId string, params UpdateShipmentStateParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetBags operation middleware
func (siw *ServerInterfaceWrapper) GetBags(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBagsParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %s", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetBags(c, params)
}

// CreateBag operation middleware
func (siw *ServerInterfaceWrapper) CreateBag(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateBagParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.CreateBag(c, params)
}

// GetAttributes operation middleware
func (siw *ServerInterfaceWrapper) GetAttributes(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAttributesParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetAttributes(c, params)
}

// UpdateAttribute operation middleware
func (siw *ServerInterfaceWrapper) UpdateAttribute(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateAttributeParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", c.Request.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter type: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.UpdateAttribute(c, params)
}

// BagContainerization operation middleware
func (siw *ServerInterfaceWrapper) BagContainerization(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params BagContainerizationParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.BagContainerization(c, params)
}

// GetStateTemplateConfig operation middleware
func (siw *ServerInterfaceWrapper) GetStateTemplateConfig(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetStateTemplateConfig(c)
}

// PutStateTemplateConfig operation middleware
func (siw *ServerInterfaceWrapper) PutStateTemplateConfig(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.PutStateTemplateConfig(c)
}

// GetBag operation middleware
func (siw *ServerInterfaceWrapper) GetBag(c *gin.Context) {

	var err error

	// ------------- Path parameter "bagId" -------------
	var bagId string

	err = runtime.BindStyledParameter("simple", false, "bagId", c.Param("bagId"), &bagId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter bagId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBagParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetBag(c, bagId, params)
}

// UpdateBag operation middleware
func (siw *ServerInterfaceWrapper) UpdateBag(c *gin.Context) {

	var err error

	// ------------- Path parameter "bagId" -------------
	var bagId string

	err = runtime.BindStyledParameter("simple", false, "bagId", c.Param("bagId"), &bagId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter bagId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateBagParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.UpdateBag(c, bagId, params)
}

// SealBag operation middleware
func (siw *ServerInterfaceWrapper) SealBag(c *gin.Context) {

	var err error

	// ------------- Path parameter "bagId" -------------
	var bagId string

	err = runtime.BindStyledParameter("simple", false, "bagId", c.Param("bagId"), &bagId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter bagId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SealBagParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.SealBag(c, bagId, params)
}

// GetBagState operation middleware
func (siw *ServerInterfaceWrapper) GetBagState(c *gin.Context) {

	var err error

	// ------------- Path parameter "bagId" -------------
	var bagId string

	err = runtime.BindStyledParameter("simple", false, "bagId", c.Param("bagId"), &bagId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter bagId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBagStateParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetBagState(c, bagId, params)
}

// UpdateBagState operation middleware
func (siw *ServerInterfaceWrapper) UpdateBagState(c *gin.Context) {

	var err error

	// ------------- Path parameter "bagId" -------------
	var bagId string

	err = runtime.BindStyledParameter("simple", false, "bagId", c.Param("bagId"), &bagId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter bagId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateBagStateParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.UpdateBagState(c, bagId, params)
}

// UnsealBag operation middleware
func (siw *ServerInterfaceWrapper) UnsealBag(c *gin.Context) {

	var err error

	// ------------- Path parameter "bagId" -------------
	var bagId string

	err = runtime.BindStyledParameter("simple", false, "bagId", c.Param("bagId"), &bagId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter bagId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UnsealBagParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.UnsealBag(c, bagId, params)
}

// GetShipments operation middleware
func (siw *ServerInterfaceWrapper) GetShipments(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShipmentsParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %s", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetShipments(c, params)
}

// CreateShipment operation middleware
func (siw *ServerInterfaceWrapper) CreateShipment(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateShipmentParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.CreateShipment(c, params)
}

// UpdateShipmentbyClient operation middleware
func (siw *ServerInterfaceWrapper) UpdateShipmentbyClient(c *gin.Context) {

	var err error

	// ------------- Path parameter "shipmentId" -------------
	var shipmentId string

	err = runtime.BindStyledParameter("simple", false, "shipmentId", c.Param("shipmentId"), &shipmentId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter shipmentId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateShipmentbyClientParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.UpdateShipmentbyClient(c, shipmentId, params)
}

// GetShipmentAttributes operation middleware
func (siw *ServerInterfaceWrapper) GetShipmentAttributes(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShipmentAttributesParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetShipmentAttributes(c, params)
}

// UpdateShipmentAttribute operation middleware
func (siw *ServerInterfaceWrapper) UpdateShipmentAttribute(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateShipmentAttributeParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", c.Request.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter type: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.UpdateShipmentAttribute(c, params)
}

// GetShipmentStateTemplateConfig operation middleware
func (siw *ServerInterfaceWrapper) GetShipmentStateTemplateConfig(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetShipmentStateTemplateConfig(c)
}

// PutShipmentStateTemplateConfig operation middleware
func (siw *ServerInterfaceWrapper) PutShipmentStateTemplateConfig(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.PutShipmentStateTemplateConfig(c)
}

// Containerize operation middleware
func (siw *ServerInterfaceWrapper) Containerize(c *gin.Context) {

	var err error

	// ------------- Path parameter "containerId" -------------
	var containerId string

	err = runtime.BindStyledParameter("simple", false, "containerId", c.Param("containerId"), &containerId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter containerId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ContainerizeParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.Containerize(c, containerId, params)
}

// ReopenShipment operation middleware
func (siw *ServerInterfaceWrapper) ReopenShipment(c *gin.Context) {

	var err error

	// ------------- Path parameter "shipmentId" -------------
	var shipmentId string

	err = runtime.BindStyledParameter("simple", false, "shipmentId", c.Param("shipmentId"), &shipmentId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter shipmentId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ReopenShipmentParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.ReopenShipment(c, shipmentId, params)
}

// GetShipment operation middleware
func (siw *ServerInterfaceWrapper) GetShipment(c *gin.Context) {

	var err error

	// ------------- Path parameter "shipmentId" -------------
	var shipmentId string

	err = runtime.BindStyledParameter("simple", false, "shipmentId", c.Param("shipmentId"), &shipmentId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter shipmentId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShipmentParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetShipment(c, shipmentId, params)
}

// UpdateShipment operation middleware
func (siw *ServerInterfaceWrapper) UpdateShipment(c *gin.Context) {

	var err error

	// ------------- Path parameter "shipmentId" -------------
	var shipmentId string

	err = runtime.BindStyledParameter("simple", false, "shipmentId", c.Param("shipmentId"), &shipmentId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter shipmentId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateShipmentParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.UpdateShipment(c, shipmentId, params)
}

// GetShipmentState operation middleware
func (siw *ServerInterfaceWrapper) GetShipmentState(c *gin.Context) {

	var err error

	// ------------- Path parameter "shipmentId" -------------
	var shipmentId string

	err = runtime.BindStyledParameter("simple", false, "shipmentId", c.Param("shipmentId"), &shipmentId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter shipmentId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShipmentStateParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetShipmentState(c, shipmentId, params)
}

// UpdateShipmentState operation middleware
func (siw *ServerInterfaceWrapper) UpdateShipmentState(c *gin.Context) {

	var err error

	// ------------- Path parameter "shipmentId" -------------
	var shipmentId string

	err = runtime.BindStyledParameter("simple", false, "shipmentId", c.Param("shipmentId"), &shipmentId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter shipmentId: %s", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateShipmentStateParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-COREOS-REQUEST-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-REQUEST-ID")]; found {
		var XCOREOSREQUESTID RequestId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-REQUEST-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-REQUEST-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSREQUESTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-REQUEST-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSREQUESTID = XCOREOSREQUESTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-REQUEST-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-COREOS-TENANT-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-COREOS-TENANT-ID")]; found {
		var XCOREOSTENANTID TenantId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-COREOS-TENANT-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-COREOS-TENANT-ID", runtime.ParamLocationHeader, valueList[0], &XCOREOSTENANTID)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-COREOS-TENANT-ID: %s", err), http.StatusBadRequest)
			return
		}

		params.XCOREOSTENANTID = XCOREOSTENANTID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-COREOS-TENANT-ID is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.UpdateShipmentState(c, shipmentId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {

	errorHandler := options.ErrorHandler

	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/bags", wrapper.GetBags)

	router.POST(options.BaseURL+"/bags", wrapper.CreateBag)

	router.GET(options.BaseURL+"/bags/config/attributes", wrapper.GetAttributes)

	router.PUT(options.BaseURL+"/bags/config/attributes", wrapper.UpdateAttribute)

	router.POST(options.BaseURL+"/bags/config/containerization/upload", wrapper.BagContainerization)

	router.GET(options.BaseURL+"/bags/config/state-machine", wrapper.GetStateTemplateConfig)

	router.PUT(options.BaseURL+"/bags/config/state-machine", wrapper.PutStateTemplateConfig)

	router.GET(options.BaseURL+"/bags/:bagId", wrapper.GetBag)

	router.PUT(options.BaseURL+"/bags/:bagId", wrapper.UpdateBag)

	router.PUT(options.BaseURL+"/bags/:bagId/seal/", wrapper.SealBag)

	router.GET(options.BaseURL+"/bags/:bagId/state/", wrapper.GetBagState)

	router.PUT(options.BaseURL+"/bags/:bagId/transition/state/", wrapper.UpdateBagState)

	router.PUT(options.BaseURL+"/bags/:bagId/unseal/", wrapper.UnsealBag)

	router.GET(options.BaseURL+"/shipments", wrapper.GetShipments)

	router.POST(options.BaseURL+"/shipments", wrapper.CreateShipment)

	router.PUT(options.BaseURL+"/shipments/client/:shipmentId", wrapper.UpdateShipmentbyClient)

	router.GET(options.BaseURL+"/shipments/config/attributes", wrapper.GetShipmentAttributes)

	router.PUT(options.BaseURL+"/shipments/config/attributes", wrapper.UpdateShipmentAttribute)

	router.GET(options.BaseURL+"/shipments/config/state-machine", wrapper.GetShipmentStateTemplateConfig)

	router.PUT(options.BaseURL+"/shipments/config/state-machine", wrapper.PutShipmentStateTemplateConfig)

	router.PUT(options.BaseURL+"/shipments/containerize/:containerId/", wrapper.Containerize)

	router.PUT(options.BaseURL+"/shipments/reopen/:shipmentId", wrapper.ReopenShipment)

	router.GET(options.BaseURL+"/shipments/:shipmentId", wrapper.GetShipment)

	router.PUT(options.BaseURL+"/shipments/:shipmentId", wrapper.UpdateShipment)

	router.GET(options.BaseURL+"/shipments/:shipmentId/state/", wrapper.GetShipmentState)

	router.PUT(options.BaseURL+"/shipments/:shipmentId/transition/state/", wrapper.UpdateShipmentState)

	return router
}
